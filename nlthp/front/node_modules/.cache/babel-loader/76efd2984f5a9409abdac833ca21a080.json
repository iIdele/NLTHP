{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport { choosePhaseStartActivePlayer, manageOverflowIndex } from './playersService.js';\n/**\r\n * cardsService provides key services to the App that\r\n * regard the Poker game cards. Such services include \r\n * shuffling the cards, dealing the cards finding \r\n * the best hand, etc.\r\n */\n\n/*\r\nGenerate the deck of 52 cards \r\n*/\n\nconst makeDeckOfCards = () => {\n  const deck = []; // get every combination of suit and value\n\n  for (let suit of suits) {\n    for (let card of cards) {\n      deck.push({\n        cardFace: card,\n        suit: suit,\n        value: VALUE_MAP[card]\n      });\n    }\n  }\n\n  return deck;\n};\n/*\r\n  Shuffle cards to randomize their order\r\n */\n\n\nconst shuffleCards = deck => {\n  let shuffledDeck = new Array(totalNumCards);\n  let filledSlots = [];\n\n  for (let i = 0; i < totalNumCards; i++) {\n    // if all cards except 1 are given \n    if (i === 51) {\n      // assign the last slot to the remaining card\n      const lastSlot = shuffledDeck.findIndex(el => typeof el == 'undefined');\n      shuffledDeck[lastSlot] = deck[i];\n      filledSlots.push(lastSlot);\n    } else {\n      // randomize order of all cards one by one\n      let shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\n\n      while (filledSlots.includes(shuffleToPosition)) {\n        shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\n      }\n\n      shuffledDeck[shuffleToPosition] = deck[i];\n      filledSlots.push(shuffleToPosition);\n    }\n  }\n\n  return shuffledDeck;\n};\n/*\r\n  Deal players cards at start of each hand\r\n */\n\n\nconst dealPlayerCards = state => {\n  state.clearCards = false;\n  let delayAnimation = 0; // deal cards until every player at table has 2\n\n  while (state.players[state.activePlayerIndex].cards.length < 2) {\n    const {\n      mutableDeckCopy,\n      chosenCards\n    } = getCards(state.deck, 1); // add animation delay \n\n    chosenCards.delayAnimation = delayAnimation;\n    delayAnimation = delayAnimation + 250;\n    const newDeck = [...mutableDeckCopy];\n    state.players[state.activePlayerIndex].cards.push(chosenCards);\n    state.deck = newDeck;\n    state.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\n  }\n\n  if (state.players[state.activePlayerIndex].cards.length === 2) {\n    state.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up'); // set first phase of betting\n\n    state.phase = 'first round';\n    return state;\n  }\n};\n/*\r\n  Find random start position for giving cards (assigns dealer chip)\r\n */\n\n\nconst randomStartPosition = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst totalNumCards = 52;\nconst cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\nconst suits = ['Heart', 'Spade', 'Club', 'Diamond']; // start from 2 as A (or 1) is the higest ranking card\n\nconst VALUE_MAP = {\n  2: 1,\n  3: 2,\n  4: 3,\n  5: 4,\n  6: 5,\n  7: 6,\n  8: 7,\n  9: 8,\n  10: 9,\n  J: 10,\n  Q: 11,\n  K: 12,\n  A: 13\n};\n/*\r\n  Deal flop cards\r\n */\n\nconst dealFlopCards = state => {\n  let delayAnimation = 0;\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 3); // deal first 3 chosen flop cards\n\n  for (let card of chosenCards) {\n    // add animation delay \n    card.delayAnimation = delayAnimation;\n    delayAnimation = delayAnimation + 250;\n    state.communityCards.push(card);\n  }\n\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set second phase of betting\n\n  state.phase = 'second round';\n  return state;\n};\n/*\r\n  Deal turn cards\r\n */\n\n\nconst dealTurnCards = state => {\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 1);\n  chosenCards.delayAnimation = 0;\n  state.communityCards.push(chosenCards);\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set third phase of betting\n\n  state.phase = 'third round';\n  return state;\n};\n/*\r\n  Deal river cards\r\n */\n\n\nconst dealRiverCards = state => {\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 1);\n  chosenCards.delayAnimation = 0;\n  state.communityCards.push(chosenCards);\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set fourth phase of betting\n\n  state.phase = 'fourth round';\n  return state;\n};\n/*\r\n  Deal table Community cards \r\n */\n\n\nconst dealOtherCommunityCards = state => {\n  // check number of cards left to deal\n  const cardsToPop = 5 - state.communityCards.length;\n\n  if (cardsToPop >= 1) {\n    let delayAnimation = 0;\n    const {\n      mutableDeckCopy,\n      chosenCards\n    } = getShowdownCards(state.deck, cardsToPop);\n\n    for (let card of chosenCards) {\n      card.delayAnimation = delayAnimation;\n      delayAnimation = delayAnimation + 250;\n      state.communityCards.push(card);\n    }\n\n    state.deck = mutableDeckCopy;\n  } // when completed move to showdown phase (phase to check winners of hand)\n\n\n  state.phase = 'showdown';\n  return state;\n};\n/*\r\nGet cards of players that are part of showdown\r\n*/\n\n\nconst getShowdownCards = (deck, numToPop) => {\n  // make shallow copy of deck to not alter original deck attributes\n  const mutableDeckCopy = [...deck];\n  let chosenCards; // get last card \n\n  if (numToPop === 1) {\n    chosenCards = [mutableDeckCopy.pop()];\n  } else {\n    // get chosen cards from mutable deck copy one by one\n    chosenCards = [];\n\n    for (let i = 0; i < numToPop; i++) {\n      chosenCards.push(mutableDeckCopy.pop());\n    }\n  }\n\n  return {\n    mutableDeckCopy,\n    chosenCards\n  };\n};\n/*\r\n  Find best hand amongst players still in a hand\r\n */\n\n\nconst findBestHand = (hand, bestRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData) => {\n  // check if hand matches any value from best to worst (Royal Flush to High Card)\n  switch (bestRank) {\n    // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n    case 'Royal Flush':\n      {\n        return flushCards.slice(0, 5);\n      }\n    // check if hand is five cards in sequence (all of same suit)\n\n    case 'Straight Flush':\n      {\n        if (isLowStraightFlush && concurrentSFCardValues.length < 5) {\n          concurrentSFCardValuesLow[0] = 13;\n          return concurrentSFCardValuesLow.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []).reverse();\n        } else {\n          return concurrentSFCardValues.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []);\n        }\n      }\n    // check if hand is four cards all of the same denomination\n\n    case 'Four Of A Kind':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 4; i++) {\n          const indexOfQuad = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.quads[0].face);\n          bestHand.push(mutableHand[indexOfQuad]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfQuad);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 1));\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n\n    case 'Full House':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        if (frequencyHistogramMetaData.tripples.length > 1) {\n          for (let i = 0; i < 3; i++) {\n            const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n            bestHand.push(mutableHand[indexOfTripple]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n          }\n\n          for (let i = 0; i < 2; i++) {\n            const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[1].face);\n            bestHand.push(mutableHand[indexOfPair]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n          }\n\n          return bestHand;\n        } else {\n          for (let i = 0; i < 3; i++) {\n            const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n            bestHand.push(mutableHand[indexOfTripple]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n          }\n\n          for (let i = 0; i < 2; i++) {\n            const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\n            bestHand.push(mutableHand[indexOfPair]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n          }\n\n          return bestHand;\n        }\n      }\n    // check if hand is five cards all of the same suit\n\n    case 'Flush':\n      {\n        return flushCards.slice(0, 5);\n      }\n    // check if hand is five cards of any suit in sequence\n\n    case 'Straight':\n      {\n        if (isLowStraight && concurrentCardValues.length < 5) {\n          concurrentCardValuesLow[0] = 13;\n          return concurrentCardValuesLow.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(hand[hand.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []).reverse();\n        } else {\n          return concurrentCardValues.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(hand[hand.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []);\n        }\n      }\n    // check if hand is three cards of the same denomination and two unmatched cards\n\n    case 'Three Of A Kind':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 3; i++) {\n          const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n          bestHand.push(mutableHand[indexOfTripple]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 2));\n      }\n    // check if hand is two sets of two cards of the same denomination and any fifth card\n\n    case 'Two Pair':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n        }\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[1].face);\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 1));\n      }\n    // check if hand is two cards of the same denomination and three unmatched cards\n\n    case 'Pair':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(card => card.cardFace === frequencyHistogramMetaData.pairs[0].face); // CONSIDER : \n\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((card, index) => index !== indexOfPair);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 3));\n      }\n    // check if hand is all five cards are unmatched\n\n    case 'No Pair':\n      {\n        return hand.slice(0, 5);\n      }\n\n    default:\n      throw Error('Recieved unfamiliar rank argument in findBestHand()');\n  }\n};\n/*\r\nRank hands of players still active in hand\r\n*/\n\n\nconst rankPlayersHands = (state, contestants) => {\n  // map of possible hand rankings\n  const rankMap = new Map([['Royal Flush', []], ['Straight Flush', []], ['Four Of A Kind', []], ['Full House', []], ['Flush', []], ['Straight', []], ['Three Of A Kind', []], ['Two Pair', []], ['Pair', []], ['No Pair', []]]);\n\n  for (let contestant of contestants) {\n    const playerIndex = state.players.findIndex(player => player.name === contestant);\n    const player = state.players[playerIndex]; // if player is active in hand\n\n    if (!player.folded) {\n      // rank player hand\n      rankMap.get(player.showDownHand.bestHandRank).push({\n        name: player.name,\n        playerIndex,\n        bestHand: player.showDownHand.bestHand\n      });\n    }\n  }\n\n  return rankMap;\n};\n/*\r\nGenerate set of five cards that add value to hand\r\n*/\n\n\nconst generateValueSet = hand => {\n  return Array.from(new Set(hand.map(cardInfo => cardInfo.value)));\n};\n/*\r\n  Determine ranking order of players' hands\r\n */\n\n\nconst determinePlayerHandsHierarchy = (sortedComparator, handRank) => {\n  let winnerHierarchy = [];\n  let loserHierarchy = [];\n\n  const processComparator = (comparator, round = 0) => {\n    if (comparator[0].length === 1) {\n      const {\n        name,\n        bestHand\n      } = comparator[0][0];\n      winnerHierarchy = winnerHierarchy.concat([{\n        name,\n        bestHand,\n        handRank\n      }]);\n      return;\n    }\n\n    let filterableComparator = sortedComparator.map(el => el);\n    const frame = comparator[round];\n    const {\n      winningFrame,\n      losingFrame\n    } = handleSnapshotFrame(frame); // find order of players who did not win hand\n\n    if (losingFrame.length > 0) {\n      const lowerTierComparator = filterableComparator.map(frame => {\n        return frame.filter(snapshot => {\n          return losingFrame.some(snapshotToMatchName => {\n            return snapshotToMatchName.name === snapshot.name;\n          });\n        });\n      }); // Push the filtered comparator to the start of the losers queue. \n\n      loserHierarchy = [lowerTierComparator].concat(loserHierarchy);\n    } // if only one winner they are best hand\n\n\n    if (winningFrame.length === 1) {\n      const {\n        name,\n        bestHand\n      } = winningFrame[0];\n      winnerHierarchy = winnerHierarchy.concat([{\n        name,\n        bestHand,\n        handRank\n      }]); // find order of players who won hand if more than one\n    } else if (round === sortedComparator.length - 1) {\n      const filteredWinnerSnapshots = winningFrame.map(snapshot => ({\n        name: snapshot.name,\n        bestHand: snapshot.bestHand,\n        handRank\n      }));\n      winnerHierarchy = winnerHierarchy.concat([filteredWinnerSnapshots]);\n    } else {\n      const higherTierComparator = filterableComparator.map(frame => {\n        return frame.filter(snapshot => {\n          return winningFrame.some(snapshotToMatchName => {\n            return snapshotToMatchName.name === snapshot.name;\n          });\n        });\n      });\n      processComparator(higherTierComparator, round + 1);\n    }\n  };\n\n  const processLowTierComparators = loserHierarchyFrame => {\n    if (loserHierarchy.length > 0) {\n      const loserComparatorToProcess = loserHierarchyFrame[0];\n      loserHierarchy = loserHierarchyFrame.slice(1);\n      processComparator(loserComparatorToProcess);\n      processLowTierComparators(loserHierarchy);\n    }\n  };\n\n  processComparator(sortedComparator);\n  processLowTierComparators(loserHierarchy);\n  return winnerHierarchy;\n};\n/*\r\n  Build ranking of hands of each player still in hand\r\n */\n\n\nconst buildPlayerRankings = state => {\n  // only consider players still active in hand\n  const activePlayers = state.players.filter(player => !player.folded);\n  let hierarchy = []; // map of possible hand rankings\n\n  const rankMap = new Map([['Royal Flush', []], ['Straight Flush', []], ['Four Of A Kind', []], ['Full House', []], ['Flush', []], ['Straight', []], ['Three Of A Kind', []], ['Two Pair', []], ['Pair', []], ['No Pair', []]]); // for each player find rank and add to ranking map\n\n  activePlayers.forEach((player, playerIndex) => {\n    const {\n      name,\n      showDownHand: {\n        bestHandRank,\n        bestHand\n      }\n    } = player;\n    rankMap.get(bestHandRank).push({\n      name,\n      bestHand,\n      playerIndex\n    });\n  });\n\n  for (const [handRank, playersWhoHoldThisRank] of rankMap) {\n    if (playersWhoHoldThisRank.length > 0) {\n      // only one player can have Royal Flush so they would win regardless of the rest\n      if (handRank === 'Royal Flush') {\n        const formattedPlayersWhoHoldThisRank = playersWhoHoldThisRank.map(player => ({\n          name: player.name,\n          bestHand: player.bestHand,\n          handRank\n        }));\n        hierarchy = hierarchy.concat(formattedPlayersWhoHoldThisRank);\n        continue;\n      } // if only one player has a ranking that player is the best for that ranking\n\n\n      if (playersWhoHoldThisRank.length === 1) {\n        const {\n          name,\n          bestHand\n        } = playersWhoHoldThisRank[0];\n        hierarchy = hierarchy.concat([{\n          name,\n          bestHand,\n          handRank\n        }]); // if more than one player has same ranking must find which one has higher value\n      } else if (playersWhoHoldThisRank.length > 1) {\n        const sortedComparator = createRankingsComparator(handRank, playersWhoHoldThisRank).map(snapshot => {\n          return snapshot.sort((a, b) => b.card.value - a.card.value);\n        });\n        const winnerHierarchy = determinePlayerHandsHierarchy(sortedComparator, handRank);\n        hierarchy = hierarchy.concat(winnerHierarchy);\n      }\n    }\n  }\n\n  return hierarchy;\n};\n/*\r\n  Handle and get snapshot with winners and losers of hand\r\n */\n\n\nconst handleSnapshotFrame = frame => {\n  const highValue = frame[0].card.value;\n  const winningFrame = frame.filter(snapshot => snapshot.card.value === highValue);\n  const losingFrame = frame.filter(snapshot => snapshot.card.value < highValue);\n  return {\n    winningFrame,\n    losingFrame\n  };\n};\n/*\r\nGet cards dealt to a player\r\n*/\n\n\nconst getCards = (deck, numToGet) => {\n  // make shallow copy of deck to not alter original deck attributes\n  const mutableDeckCopy = [...deck];\n  let chosenCards;\n\n  if (numToGet === 1) {\n    // get last card \n    chosenCards = mutableDeckCopy.pop();\n  } else {\n    // get chosen cards from mutable deck copy one by one\n    chosenCards = [];\n\n    for (let i = 0; i < numToGet; i++) {\n      chosenCards.push(mutableDeckCopy.pop());\n    }\n  }\n\n  return {\n    mutableDeckCopy,\n    chosenCards\n  };\n};\n/*\r\n  Assign winnings to hand winners (handles pot splits too)\r\n */\n\n\nconst assignWinnings = (state, rankMap, prize) => {\n  let winnerFound = false; // find hand winners\n\n  rankMap.forEach((contestants, rank, map) => {\n    if (!winnerFound) {\n      // if only one player active in hand they win\n      if (contestants.length === 1) {\n        winnerFound = true;\n        console.log(\"Winner, \", contestants[0].name, \" , beating out the competition with a \", rank);\n        state = payWinnings(state, contestants, prize, rank); // if more than one player active in hand find winner\n      } else if (contestants.length > 1) {\n        console.log(contestants);\n        winnerFound = true; // get active players hand rankings\n\n        const winners = findHandWinner(createRankingsComparator(rank, contestants), rank); // if only one player wins they get all the pot\n\n        if (winners.length === 1) {\n          console.log(\"Winner, \", winners[0].name, \" , beating out the competition with a \", rank);\n          state = payWinnings(state, winners, prize, rank); // if multilple players win the pot is split amongst them\n        } else {\n          console.log(\"We have a tie! Split the pot amongst \", winners, \" Who will take the pot with their \", rank);\n          state = payWinnings(state, winners, prize, rank);\n        }\n      }\n    }\n  });\n  return state;\n};\n/*\r\n  Assign side pots when there are multiple winners for the same hand\r\n */\n\n\nconst assignSidePots = state => {\n  // find winners of hand\n  state.playerHierarchy = buildPlayerRankings(state);\n  console.log(\"Ultimate Player Hierarchy Determined:\");\n  console.log(state.playerHierarchy); // assign each side pot to the corresponding winner\n\n  for (let sidePot of state.sidePots) {\n    const rankMap = rankPlayersHands(state, sidePot.contestants);\n    state = assignWinnings(state, rankMap, sidePot.potValue);\n  }\n\n  state.players = state.players.map(player => ({ ...player,\n    roundEndChips: player.chips\n  }));\n  return state;\n};\n/*\r\n  Pay winnings to hand winners\r\n */\n\n\nconst payWinnings = (state, winners, prize, rank) => {\n  // if only one winner they win all the pot\n  if (winners.length === 1) {\n    state.showDownMessages = state.showDownMessages.concat([{\n      users: [winners[0].name],\n      prize,\n      rank\n    }]);\n    console.log(\"Transferring \", prize, \" chips to \", winners[0].name);\n    state.players[winners[0].playerIndex].chips += prize;\n    state.pot -= prize; // if more than one winner split pot accordingly between them\n  } else if (winners.length > 1) {\n    const overflow = prize % winners.length;\n    const splitPot = Math.floor(prize / winners.length);\n    console.log(\"Mediating Tie. Total Prize \", prize, \" split into \", winners.length, \" portions with an overflow of \", overflow);\n    state.showDownMessages = state.showDownMessages.concat([{\n      users: winners.map(winner => winner.name),\n      prize: splitPot,\n      rank\n    }]);\n    winners.forEach(winner => {\n      state.players[winner.playerIndex].chips += splitPot;\n      state.pot -= splitPot;\n    });\n  }\n\n  return state;\n};\n/*\r\n  Create hand rankings comparator to compare hand rankings\r\n */\n\n\nconst createRankingsComparator = (rank, playerData) => {\n  let comparator;\n\n  switch (rank) {\n    // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n    case 'Royal Flush':\n      {\n        comparator = Array.from({\n          length: 1\n        });\n        playerData.forEach((playerShowdownData, index) => {\n          comparator.push({\n            // there can only be one royal flush which will be the winner regardless of other hand rankings\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is four cards all of the same denomination\n\n    case 'Four Of A Kind':\n      {\n        comparator = Array.from({\n          length: 2\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // four cards all of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // last card is unmatched\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n\n    case 'Full House':\n      {\n        comparator = Array.from({\n          length: 2\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // three cards of one denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // two cards of another denomination\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n    // or if all five cards are unmatched\n\n    case 'Flush':\n    case 'No Pair':\n      {\n        comparator = Array.from({\n          length: 5\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          for (let i = 0; i < 5; i++) {\n            comparator[i].push({\n              // check all 5 cards of a flush or no-pair\n              card: playerData[index].bestHand[i],\n              name: playerData[index].name,\n              playerIndex: playerData[index].playerIndex,\n              bestHand: playerData[index].bestHand\n            });\n          }\n        });\n        break;\n      }\n    // check if hand is three cards of the same denomination and two unmatched cards\n\n    case 'Three Of A Kind':\n      {\n        comparator = Array.from({\n          length: 3\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // three cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // fourth card is unmatched\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fifth card is unmatched\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is five cards of any suit in sequence\n    // or if hand is five cards in sequence (all of same suit)\n\n    case 'Straight':\n    case 'Straight Flush':\n      {\n        comparator = Array.from({\n          length: 1\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // check highest card of a straight as it will determine the straight value\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is two sets of two cards of the same denomination and any fifth card\n\n    case 'Two Pair':\n      {\n        comparator = Array.from({\n          length: 3\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // two cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // another two cards of the same denomination\n            card: playerData[index].bestHand[2],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fifth unmatched card\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is two cards of the same denomination and three unmatched cards\n\n    case 'Pair':\n      {\n        comparator = Array.from({\n          length: 4\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // two cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // third unmtached card\n            card: playerData[index].bestHand[2],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fourth unmtached card\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[3].push({\n            // fifth unmtached card\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n\n    default:\n      throw Error('Recieved unfamiliar rank argument in createRankingsComparator()');\n  }\n\n  return comparator;\n};\n/*\r\n  Find current hand winner\r\n */\n\n\nconst findHandWinner = (comparator, rank) => {\n  let winners;\n  if (rank === 'Royal Flush') return comparator;\n\n  for (let i = 0; i < comparator.length; i++) {\n    let highValue = 0;\n    let losers = []; // sort player rankings comparator \n\n    winners = comparator[i].sort((a, b) => b.card.value - a.card.value).reduce((acc, cur, index) => {\n      // add player with higher ranking hands first\n      if (cur.card.value > highValue) {\n        highValue = cur.card.value;\n        acc.push({\n          name: cur.name,\n          playerIndex: cur.playerIndex\n        });\n        return acc;\n      } else if (cur.card.value === highValue) {\n        acc.push({\n          name: cur.name,\n          playerIndex: cur.playerIndex\n        });\n        return acc; // then add non active players (back of list)\n      } else if (cur.card.value < highValue) {\n        losers.push(cur.name);\n        return acc;\n      }\n    }, []);\n\n    if (winners.length === 1 || i === comparator.length) {\n      return winners;\n    } else {\n      if (losers.length >= 1) {\n        losers.forEach(nameToExtract => {\n          comparator = comparator.map(snapshot => snapshot.filter(el => el.name !== nameToExtract));\n        });\n      }\n    }\n  }\n\n  return winners;\n};\n/*\r\n  Check if hand is a Flush\r\n */\n\n\nconst checkIfFlush = suitHistogram => {\n  let isFlush;\n  let flushedSuit; // check if all five cards have the same suit\n\n  for (let suit in suitHistogram) {\n    if (suitHistogram[suit] >= 5) {\n      return {\n        isFlush: true,\n        flushedSuit: suit\n      };\n    }\n  }\n\n  return {\n    isFlush: false,\n    flushedSuit: null\n  };\n};\n/*\r\n  Check if hand is straight with Ace, two, three, four, five\r\n */\n\n\nconst checkIfLowerStraight = valueSetCopy => {\n  let numConcurrentCards = 0;\n  let concurrentCardValuesLow = []; // Convert Ace which has highest value of 13 to lowest value 0 from which straight would start\n\n  valueSetCopy[0] = 0; // sort card values\n\n  const sortedValueSetCopy = valueSetCopy.map(el => el).sort((a, b) => a - b); // check if Ace, two, three, four, five are found\n\n  for (let i = 1; i < 5; i++) {\n    if (numConcurrentCards >= 5) {\n      return {\n        isLowStraight: true,\n        concurrentCardValuesLow\n      };\n    }\n\n    if (sortedValueSetCopy[i] - sortedValueSetCopy[i - 1] === 1) {\n      if (numConcurrentCards === 0) {\n        numConcurrentCards = 2;\n        concurrentCardValuesLow.push(sortedValueSetCopy[i - 1]);\n        concurrentCardValuesLow.push(sortedValueSetCopy[i]);\n      } else {\n        numConcurrentCards++;\n        concurrentCardValuesLow.push(sortedValueSetCopy[i]);\n      }\n    } else {\n      numConcurrentCards = 0;\n      concurrentCardValuesLow = [];\n    }\n  }\n\n  if (numConcurrentCards >= 5) {\n    return {\n      isLowStraight: true,\n      concurrentCardValuesLow\n    };\n  } else {\n    return {\n      isLowStraight: false,\n      concurrentCardValuesLow\n    };\n  }\n};\n/*\r\n  Check if hand is a Royal Flush\r\n */\n\n\nconst checkIfRoyalFlush = flushMatchCards => {\n  // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n  if (flushMatchCards[0].value === 13 && flushMatchCards[1].value === 12 && flushMatchCards[2].value === 11 && flushMatchCards[3].value === 10 && flushMatchCards[4].value === 10) {\n    return true;\n  } else {\n    return false;\n  }\n};\n/*\r\n  Check if hand is a Straight\r\n */\n\n\nconst checkIfStraight = valueSet => {\n  // if less than five cards are valuable to the hand it is not a straight\n  if (valueSet.length < 5) return false;\n  let numConcurrentCards = 0;\n  let concurrentCardValues = []; // check if hand is five cards of any suit in sequence\n\n  for (let i = 1; i < valueSet.length; i++) {\n    if (numConcurrentCards === 5) {\n      return {\n        isStraight: true,\n        concurrentCardValues\n      };\n    }\n\n    if (valueSet[i] - valueSet[i - 1] === -1) {\n      if (numConcurrentCards === 0) {\n        numConcurrentCards = 2;\n        concurrentCardValues.push(valueSet[i - 1]);\n        concurrentCardValues.push(valueSet[i]);\n      } else {\n        numConcurrentCards++;\n        concurrentCardValues.push(valueSet[i]);\n      }\n    } else {\n      numConcurrentCards = 0;\n      concurrentCardValues = [];\n    }\n  }\n\n  if (numConcurrentCards >= 5) {\n    return {\n      isStraight: true,\n      concurrentCardValues\n    };\n  } else {\n    // check if is straight with Ace, two, three, four, five\n    if (valueSet[0] === 13) {\n      let {\n        isLowStraight,\n        concurrentCardValuesLow\n      } = checkIfLowerStraight(cloneDeep(valueSet));\n      if (isLowStraight) return {\n        isStraight: true,\n        isLowStraight,\n        concurrentCardValues,\n        concurrentCardValuesLow\n      };\n    }\n\n    return {\n      isStraight: false,\n      isLowStraight: false,\n      concurrentCardValues\n    };\n  }\n};\n/*\r\n  Check if hand is a Straight Flush\r\n */\n\n\nconst checkIfStraightFlush = flushMatchCards => {\n  // check if hand is five cards in sequence (all of same suit)\n  const valueSet = generateValueSet(flushMatchCards);\n  const {\n    isStraight,\n    isLowStraight,\n    concurrentCardValues,\n    concurrentCardValuesLow\n  } = checkIfStraight(valueSet);\n  return {\n    isStraightFlush: isStraight,\n    isLowStraightFlush: isLowStraight,\n    concurrentSFCardValues: concurrentCardValues,\n    concurrentSFCardValuesLow: concurrentCardValuesLow\n  };\n};\n/*\r\n  Perform player showdown at end of hand\r\n */\n\n\nconst playerShowDown = state => {\n  // find players that are still in the hand\n  for (let player of state.players) {\n    const frequencyHistogram = {};\n    const suitHistogram = {}; // build each player's best hand\n\n    player.showDownHand.hand = player.cards.concat(state.communityCards);\n    player.showDownHand.descendingSortHand = player.showDownHand.hand.map(el => el).sort((a, b) => b.value - a.value); // This mutates showDownHand.hand in place(!!)\n\n    player.showDownHand.descendingSortHand.forEach(card => {\n      frequencyHistogram[card.cardFace] = frequencyHistogram[card.cardFace] + 1 || 1;\n      suitHistogram[card.suit] = suitHistogram[card.suit] + 1 || 1;\n    });\n    player.frequencyHistogram = frequencyHistogram;\n    player.suitHistogram = suitHistogram;\n    const valueSet = generateValueSet(player.showDownHand.descendingSortHand); // check value of each player's hand\n\n    const {\n      isFlush,\n      flushedSuit\n    } = checkIfFlush(suitHistogram);\n    const flushCards = isFlush && player.showDownHand.descendingSortHand.filter(card => card.suit === flushedSuit);\n    const isRoyalFlush = isFlush && checkIfRoyalFlush(flushCards);\n    const {\n      isStraightFlush,\n      isLowStraightFlush,\n      concurrentSFCardValues,\n      concurrentSFCardValuesLow\n    } = isFlush && checkIfStraightFlush(flushCards);\n    const {\n      isStraight,\n      isLowStraight,\n      concurrentCardValues,\n      concurrentCardValuesLow\n    } = checkIfStraight(valueSet);\n    const {\n      isFourOfAKind,\n      isFullHouse,\n      isThreeOfAKind,\n      isTwoPair,\n      isPair,\n      frequencyHistogramMetaData\n    } = checkFrequencyHistogram(player.showDownHand.descendingSortHand, frequencyHistogram);\n    const isNoPair = !isRoyalFlush && !isStraightFlush && !isFourOfAKind && !isFullHouse && !isFlush && !isStraight && !isThreeOfAKind && !isTwoPair && !isPair; // set value of each player's hand\n\n    player.showDownHand.bools = {\n      isRoyalFlush,\n      isStraightFlush,\n      isFourOfAKind,\n      isFullHouse,\n      isFlush,\n      isStraight,\n      isThreeOfAKind,\n      isTwoPair,\n      isPair,\n      isNoPair\n    };\n    player.showDownHand.heldRankHierarchy = [{\n      name: 'Royal Flush',\n      match: isRoyalFlush\n    }, {\n      name: 'Straight Flush',\n      match: isStraightFlush\n    }, {\n      name: 'Four Of A Kind',\n      match: isFourOfAKind\n    }, {\n      name: 'Full House',\n      match: isFullHouse\n    }, {\n      name: 'Flush',\n      match: isFlush\n    }, {\n      name: 'Straight',\n      match: isStraight\n    }, {\n      name: 'Three Of A Kind',\n      match: isThreeOfAKind\n    }, {\n      name: 'Two Pair',\n      match: isTwoPair\n    }, {\n      name: 'Pair',\n      match: isPair\n    }, {\n      name: 'No Pair',\n      match: isNoPair\n    }];\n    player.metaData = frequencyHistogramMetaData; // get best hand between players in showdown\n\n    const highRankPosition = player.showDownHand.heldRankHierarchy.findIndex(el => el.match === true);\n    player.showDownHand.bestHandRank = player.showDownHand.heldRankHierarchy[highRankPosition].name;\n    player.showDownHand.bestHand = findBestHand(player.showDownHand.descendingSortHand, player.showDownHand.bestHandRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData);\n  }\n\n  return assignSidePots(state);\n};\n/*\r\n  Check how many hand rankings have occured and with what frequence \r\n  and order\r\n */\n\n\nconst checkFrequencyHistogram = (hand, frequencyHistogram) => {\n  // set hand rankings to not seen \n  let isFourOfAKind = false;\n  let isFullHouse = false;\n  let isThreeOfAKind = false;\n  let isTwoPair = false;\n  let isPair = false;\n  let numTripples = 0;\n  let numPairs = 0;\n  let frequencyHistogramMetaData = {\n    pairs: [],\n    tripples: [],\n    quads: []\n  }; // check if hand is four cards all of the same denomination\n\n  for (let cardFace in frequencyHistogram) {\n    if (frequencyHistogram[cardFace] === 4) {\n      isFourOfAKind = true;\n      frequencyHistogramMetaData.quads.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    } // check if hand is three cards of the same denomination and two unmatched cards\n\n\n    if (frequencyHistogram[cardFace] === 3) {\n      isThreeOfAKind = true;\n      numTripples++;\n      frequencyHistogramMetaData.tripples.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    } // check if hand is two cards of the same denomination and three unmatched cards\n\n\n    if (frequencyHistogram[cardFace] === 2) {\n      isPair = true;\n      numPairs++;\n      frequencyHistogramMetaData.pairs.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    }\n  } // sort histogram from best hand to worst hand\n\n\n  frequencyHistogramMetaData.pairs = frequencyHistogramMetaData.pairs.map(el => el).sort((a, b) => b.value - a.value);\n  frequencyHistogramMetaData.tripples = frequencyHistogramMetaData.tripples.map(el => el).sort((a, b) => b.value - a.value);\n  frequencyHistogramMetaData.quads = frequencyHistogramMetaData.quads.map(el => el).sort((a, b) => b.value - a.value); // check if hand is three cards of one denomination and two cards of another denomination (full house)\n\n  if (numTripples >= 2 || numPairs >= 1 && numTripples >= 1) {\n    isFullHouse = true;\n  } // check if hand is two sets of two cards of the same denomination and any fifth card (Two Pairs)\n\n\n  if (numPairs >= 2) {\n    isTwoPair = true;\n  }\n\n  return {\n    isFourOfAKind,\n    isFullHouse,\n    isThreeOfAKind,\n    isTwoPair,\n    isPair,\n    frequencyHistogramMetaData\n  };\n};\n\nexport { makeDeckOfCards, shuffleCards, dealPlayerCards, getCards, dealFlopCards, dealTurnCards, dealRiverCards, dealOtherCommunityCards, playerShowDown, checkIfFlush, checkIfRoyalFlush, checkIfStraightFlush, checkIfStraight, checkFrequencyHistogram, generateValueSet };","map":{"version":3,"sources":["C:/Users/manny/2021-ca400-idelegi2-puzzuos2/src/ui/src/services/cardsService.js"],"names":["cloneDeep","choosePhaseStartActivePlayer","manageOverflowIndex","makeDeckOfCards","deck","suit","suits","card","cards","push","cardFace","value","VALUE_MAP","shuffleCards","shuffledDeck","Array","totalNumCards","filledSlots","i","lastSlot","findIndex","el","shuffleToPosition","randomStartPosition","includes","dealPlayerCards","state","clearCards","delayAnimation","players","activePlayerIndex","length","mutableDeckCopy","chosenCards","getCards","newDeck","blindIndex","big","phase","min","max","Math","ceil","floor","random","J","Q","K","A","dealFlopCards","communityCards","dealTurnCards","dealRiverCards","dealOtherCommunityCards","cardsToPop","getShowdownCards","numToPop","pop","findBestHand","hand","bestRank","flushedSuit","flushCards","concurrentCardValues","concurrentCardValuesLow","isLowStraight","isLowStraightFlush","concurrentSFCardValues","concurrentSFCardValuesLow","frequencyHistogramMetaData","slice","reduce","acc","cur","index","match","reverse","bestHand","mutableHand","indexOfQuad","quads","face","filter","concat","tripples","indexOfTripple","indexOfPair","pairs","Error","rankPlayersHands","contestants","rankMap","Map","contestant","playerIndex","player","name","folded","get","showDownHand","bestHandRank","generateValueSet","from","Set","map","cardInfo","determinePlayerHandsHierarchy","sortedComparator","handRank","winnerHierarchy","loserHierarchy","processComparator","comparator","round","filterableComparator","frame","winningFrame","losingFrame","handleSnapshotFrame","lowerTierComparator","snapshot","some","snapshotToMatchName","filteredWinnerSnapshots","higherTierComparator","processLowTierComparators","loserHierarchyFrame","loserComparatorToProcess","buildPlayerRankings","activePlayers","hierarchy","forEach","playersWhoHoldThisRank","formattedPlayersWhoHoldThisRank","createRankingsComparator","sort","a","b","highValue","numToGet","assignWinnings","prize","winnerFound","rank","console","log","payWinnings","winners","findHandWinner","assignSidePots","playerHierarchy","sidePot","sidePots","potValue","roundEndChips","chips","showDownMessages","users","pot","overflow","splitPot","winner","playerData","playerShowdownData","losers","nameToExtract","checkIfFlush","suitHistogram","isFlush","checkIfLowerStraight","valueSetCopy","numConcurrentCards","sortedValueSetCopy","checkIfRoyalFlush","flushMatchCards","checkIfStraight","valueSet","isStraight","checkIfStraightFlush","isStraightFlush","playerShowDown","frequencyHistogram","descendingSortHand","isRoyalFlush","isFourOfAKind","isFullHouse","isThreeOfAKind","isTwoPair","isPair","checkFrequencyHistogram","isNoPair","bools","heldRankHierarchy","metaData","highRankPosition","numTripples","numPairs"],"mappings":"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","sourcesContent":["import { cloneDeep } from 'lodash';\r\nimport { choosePhaseStartActivePlayer, manageOverflowIndex } from './playersService.js';\r\n\r\n/**\r\n * cardsService provides key services to the App that\r\n * regard the Poker game cards. Such services include \r\n * shuffling the cards, dealing the cards finding \r\n * the best hand, etc.\r\n */\r\n\r\n/*\r\nGenerate the deck of 52 cards \r\n*/\r\nconst makeDeckOfCards = () => {\r\n\tconst deck = [];\r\n\r\n\t// get every combination of suit and value\r\n\tfor (let suit of suits) {\r\n\t\tfor (let card of cards) {\r\n\t\t\tdeck.push({\r\n\t\t\t\tcardFace: card,\r\n\t\t\t\tsuit: suit,\r\n\t\t\t\tvalue: VALUE_MAP[card]\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\treturn deck\r\n}\r\n\r\n\r\n/*\r\n  Shuffle cards to randomize their order\r\n */\r\nconst shuffleCards = (deck) => {\r\n\tlet shuffledDeck = new Array(totalNumCards);\r\n\tlet filledSlots = [];\r\n\tfor (let i = 0; i < totalNumCards; i++) {\r\n\t\t// if all cards except 1 are given \r\n\t\tif (i === 51) {\r\n\t\t\t// assign the last slot to the remaining card\r\n\t\t\tconst lastSlot = shuffledDeck.findIndex((el) => typeof el == 'undefined');\r\n\t\t\tshuffledDeck[lastSlot] = deck[i];\r\n\t\t\tfilledSlots.push(lastSlot);\r\n\t\t} else {\r\n\t\t\t// randomize order of all cards one by one\r\n\t\t\tlet shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\r\n\t\t\twhile (filledSlots.includes(shuffleToPosition)) {\r\n\t\t\t\tshuffleToPosition = randomStartPosition(0, totalNumCards - 1);\r\n\t\t\t}\r\n\t\t\tshuffledDeck[shuffleToPosition] = deck[i];\r\n\t\t\tfilledSlots.push(shuffleToPosition);\r\n\t\t}\r\n\t}\r\n\treturn shuffledDeck\r\n}\r\n\r\n\r\n/*\r\n  Deal players cards at start of each hand\r\n */\r\nconst dealPlayerCards = (state) => {\r\n\tstate.clearCards = false;\r\n\tlet delayAnimation = 0;\r\n\t// deal cards until every player at table has 2\r\n\twhile (state.players[state.activePlayerIndex].cards.length < 2) {\r\n\t\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\r\n\t\t// add animation delay \r\n\t\tchosenCards.delayAnimation = delayAnimation;\r\n\t\tdelayAnimation = delayAnimation + 250;\r\n\r\n\t\tconst newDeck = [...mutableDeckCopy];\r\n\t\tstate.players[state.activePlayerIndex].cards.push(chosenCards);\r\n\r\n\t\tstate.deck = newDeck;\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\r\n\t}\r\n\tif (state.players[state.activePlayerIndex].cards.length === 2) {\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up');\r\n\t\t// set first phase of betting\r\n\t\tstate.phase = 'first round';\r\n\t\treturn state;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n  Find random start position for giving cards (assigns dealer chip)\r\n */\r\nconst randomStartPosition = (min, max) => {\r\n\tmin = Math.ceil(min);\r\n\tmax = Math.floor(max);\r\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nconst totalNumCards = 52;\r\nconst cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\r\nconst suits = ['Heart', 'Spade', 'Club', 'Diamond'];\r\n\r\n// start from 2 as A (or 1) is the higest ranking card\r\nconst VALUE_MAP = {\r\n\t2: 1,\r\n\t3: 2,\r\n\t4: 3,\r\n\t5: 4,\r\n\t6: 5,\r\n\t7: 6,\r\n\t8: 7,\r\n\t9: 8,\r\n\t10: 9,\r\n\tJ: 10,\r\n\tQ: 11,\r\n\tK: 12,\r\n\tA: 13,\r\n}\r\n\r\n/*\r\n  Deal flop cards\r\n */\r\nconst dealFlopCards = (state) => {\r\n\tlet delayAnimation = 0;\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 3);\r\n\r\n\t// deal first 3 chosen flop cards\r\n\tfor (let card of chosenCards) {\r\n\t\t// add animation delay \r\n\t\tcard.delayAnimation = delayAnimation;\r\n\t\tdelayAnimation = delayAnimation + 250;\r\n\t\tstate.communityCards.push(card);\r\n\t}\r\n\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set second phase of betting\r\n\tstate.phase = 'second round';\r\n\r\n\treturn state;\r\n}\r\n\r\n/*\r\n  Deal turn cards\r\n */\r\nconst dealTurnCards = (state) => {\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\tchosenCards.delayAnimation = 0;\r\n\r\n\tstate.communityCards.push(chosenCards);\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set third phase of betting\r\n\tstate.phase = 'third round'\r\n\r\n\treturn state\r\n}\r\n\r\n\r\n/*\r\n  Deal river cards\r\n */\r\nconst dealRiverCards = (state) => {\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\tchosenCards.delayAnimation = 0;\r\n\r\n\tstate.communityCards.push(chosenCards);\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set fourth phase of betting\r\n\tstate.phase = 'fourth round'\r\n\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Deal table Community cards \r\n */\r\nconst dealOtherCommunityCards = (state) => {\r\n\t// check number of cards left to deal\r\n\tconst cardsToPop = 5 - state.communityCards.length\r\n\tif (cardsToPop >= 1) {\r\n\t\tlet delayAnimation = 0;\r\n\t\tconst { mutableDeckCopy, chosenCards } = getShowdownCards(state.deck, cardsToPop);\r\n\r\n\t\tfor (let card of chosenCards) {\r\n\t\t\tcard.delayAnimation = delayAnimation;\r\n\t\t\tdelayAnimation = delayAnimation + 250;\r\n\t\t\tstate.communityCards.push(card);\r\n\t\t}\r\n\r\n\t\tstate.deck = mutableDeckCopy;\r\n\t}\r\n\t// when completed move to showdown phase (phase to check winners of hand)\r\n\tstate.phase = 'showdown'\r\n\treturn state\r\n}\r\n\r\n/*\r\nGet cards of players that are part of showdown\r\n*/\r\nconst getShowdownCards = (deck, numToPop) => {\r\n\t// make shallow copy of deck to not alter original deck attributes\r\n\tconst mutableDeckCopy = [...deck];\r\n\tlet chosenCards;\r\n\t// get last card \r\n\tif (numToPop === 1) {\r\n\t\tchosenCards = [mutableDeckCopy.pop()];\r\n\t} else {\r\n\t\t// get chosen cards from mutable deck copy one by one\r\n\t\tchosenCards = [];\r\n\t\tfor (let i = 0; i < numToPop; i++) {\r\n\t\t\tchosenCards.push(mutableDeckCopy.pop());\r\n\t\t}\r\n\t}\r\n\treturn { mutableDeckCopy, chosenCards }\r\n}\r\n\r\n/*\r\n  Find best hand amongst players still in a hand\r\n */\r\nconst findBestHand = (hand, bestRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData) => {\r\n\t// check if hand matches any value from best to worst (Royal Flush to High Card)\r\n\tswitch (bestRank) {\r\n\t\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\t\tcase ('Royal Flush'): {\r\n\t\t\treturn flushCards.slice(0, 5)\r\n\t\t}\r\n\t\t// check if hand is five cards in sequence (all of same suit)\r\n\t\tcase ('Straight Flush'): {\r\n\t\t\tif (isLowStraightFlush && concurrentSFCardValues.length < 5) {\r\n\t\t\t\tconcurrentSFCardValuesLow[0] = 13\r\n\t\t\t\treturn concurrentSFCardValuesLow.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []).reverse();\r\n\t\t\t} else {\r\n\t\t\t\treturn concurrentSFCardValues.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is four cards all of the same denomination\r\n\t\tcase ('Four Of A Kind'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tconst indexOfQuad = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.quads[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfQuad])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfQuad)\r\n\t\t\t}\r\n\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 1))\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\tcase ('Full House'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tif (frequencyHistogramMetaData.tripples.length > 1) {\r\n\t\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[1].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t\t}\r\n\t\t\t\treturn bestHand\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t\t}\r\n\t\t\t\treturn bestHand\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is five cards all of the same suit\r\n\t\tcase ('Flush'): {\r\n\t\t\treturn flushCards.slice(0, 5)\r\n\t\t}\r\n\t\t// check if hand is five cards of any suit in sequence\r\n\t\tcase ('Straight'): {\r\n\t\t\tif (isLowStraight && concurrentCardValues.length < 5) {\r\n\t\t\t\tconcurrentCardValuesLow[0] = 13\r\n\t\t\t\treturn concurrentCardValuesLow.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(hand[hand.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []).reverse();\r\n\t\t\t} else {\r\n\t\t\t\treturn concurrentCardValues.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(hand[hand.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tcase ('Three Of A Kind'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\r\n\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t}\r\n\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 2))\r\n\t\t}\r\n\t\t// check if hand is two sets of two cards of the same denomination and any fifth card\r\n\t\tcase ('Two Pair'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[1].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 1))\r\n\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tcase ('Pair'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(card => card.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\t// CONSIDER : \r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((card, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 3))\r\n\r\n\r\n\t\t}\r\n\t\t// check if hand is all five cards are unmatched\r\n\t\tcase ('No Pair'): {\r\n\t\t\treturn hand.slice(0, 5)\r\n\t\t}\r\n\t\tdefault: throw Error('Recieved unfamiliar rank argument in findBestHand()');\r\n\t}\r\n}\r\n/*\r\nRank hands of players still active in hand\r\n*/\r\nconst rankPlayersHands = (state, contestants) => {\r\n\r\n\t// map of possible hand rankings\r\n\tconst rankMap = new Map([\r\n\t\t['Royal Flush', []],\r\n\t\t['Straight Flush', []],\r\n\t\t['Four Of A Kind', []],\r\n\t\t['Full House', []],\r\n\t\t['Flush', []],\r\n\t\t['Straight', []],\r\n\t\t['Three Of A Kind', []],\r\n\t\t['Two Pair', []],\r\n\t\t['Pair', []],\r\n\t\t['No Pair', []]\r\n\t]);\r\n\r\n\tfor (let contestant of contestants) {\r\n\t\tconst playerIndex = state.players.findIndex(player => player.name === contestant);\r\n\t\tconst player = state.players[playerIndex];\r\n\t\t// if player is active in hand\r\n\t\tif (!player.folded) {\r\n\t\t\t// rank player hand\r\n\t\t\trankMap.get(player.showDownHand.bestHandRank).push({\r\n\t\t\t\tname: player.name,\r\n\t\t\t\tplayerIndex,\r\n\t\t\t\tbestHand: player.showDownHand.bestHand,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn rankMap;\r\n}\r\n\r\n/*\r\nGenerate set of five cards that add value to hand\r\n*/\r\nconst generateValueSet = (hand) => {\r\n\treturn Array.from(new Set(hand.map(cardInfo => cardInfo.value)))\r\n}\r\n\r\n/*\r\n  Determine ranking order of players' hands\r\n */\r\nconst determinePlayerHandsHierarchy = (sortedComparator, handRank) => {\r\n\tlet winnerHierarchy = [];\r\n\tlet loserHierarchy = [];\r\n\tconst processComparator = (comparator, round = 0) => {\r\n\t\tif (comparator[0].length === 1) {\r\n\t\t\tconst { name, bestHand } = comparator[0][0]\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([{ name, bestHand, handRank }])\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet filterableComparator = sortedComparator.map(el => el);\r\n\t\tconst frame = comparator[round];\r\n\t\tconst { winningFrame, losingFrame } = handleSnapshotFrame(frame);\r\n\t\t// find order of players who did not win hand\r\n\t\tif (losingFrame.length > 0) {\r\n\t\t\tconst lowerTierComparator = filterableComparator.map(frame => {\r\n\t\t\t\treturn frame.filter(snapshot => {\r\n\t\t\t\t\treturn losingFrame.some(snapshotToMatchName => {\r\n\t\t\t\t\t\treturn snapshotToMatchName.name === snapshot.name;\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\t// Push the filtered comparator to the start of the losers queue. \r\n\t\t\tloserHierarchy = [lowerTierComparator].concat(loserHierarchy);\r\n\t\t}\r\n\t\t// if only one winner they are best hand\r\n\t\tif (winningFrame.length === 1) {\r\n\t\t\tconst { name, bestHand } = winningFrame[0];\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([{\r\n\t\t\t\tname,\r\n\t\t\t\tbestHand,\r\n\t\t\t\thandRank\r\n\t\t\t}])\r\n\t\t\t// find order of players who won hand if more than one\r\n\t\t} else if (round === (sortedComparator.length - 1)) {\r\n\t\t\tconst filteredWinnerSnapshots = winningFrame.map(snapshot => ({\r\n\t\t\t\tname: snapshot.name,\r\n\t\t\t\tbestHand: snapshot.bestHand,\r\n\t\t\t\thandRank\r\n\t\t\t}))\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([filteredWinnerSnapshots]);\r\n\t\t} else {\r\n\t\t\tconst higherTierComparator = filterableComparator.map(frame => {\r\n\t\t\t\treturn frame.filter(snapshot => {\r\n\t\t\t\t\treturn winningFrame.some(snapshotToMatchName => {\r\n\t\t\t\t\t\treturn snapshotToMatchName.name === snapshot.name;\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tprocessComparator(higherTierComparator, (round + 1));\r\n\t\t}\r\n\t}\r\n\r\n\tconst processLowTierComparators = (loserHierarchyFrame) => {\r\n\t\tif (loserHierarchy.length > 0) {\r\n\t\t\tconst loserComparatorToProcess = loserHierarchyFrame[0];\r\n\t\t\tloserHierarchy = loserHierarchyFrame.slice(1);\r\n\t\t\tprocessComparator(loserComparatorToProcess);\r\n\t\t\tprocessLowTierComparators(loserHierarchy);\r\n\t\t}\r\n\t}\r\n\tprocessComparator(sortedComparator);\r\n\tprocessLowTierComparators(loserHierarchy);\r\n\treturn winnerHierarchy;\r\n}\r\n\r\n/*\r\n  Build ranking of hands of each player still in hand\r\n */\r\nconst buildPlayerRankings = (state) => {\r\n\r\n\t// only consider players still active in hand\r\n\tconst activePlayers = state.players.filter(player => !player.folded);\r\n\tlet hierarchy = [];\r\n\t// map of possible hand rankings\r\n\tconst rankMap = new Map([\r\n\t\t['Royal Flush', []],\r\n\t\t['Straight Flush', []],\r\n\t\t['Four Of A Kind', []],\r\n\t\t['Full House', []],\r\n\t\t['Flush', []],\r\n\t\t['Straight', []],\r\n\t\t['Three Of A Kind', []],\r\n\t\t['Two Pair', []],\r\n\t\t['Pair', []],\r\n\t\t['No Pair', []]\r\n\t]);\r\n\r\n\t// for each player find rank and add to ranking map\r\n\tactivePlayers.forEach((player, playerIndex) => {\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tshowDownHand: { bestHandRank, bestHand }\r\n\t\t} = player;\r\n\t\trankMap.get(bestHandRank).push({\r\n\t\t\tname,\r\n\t\t\tbestHand,\r\n\t\t\tplayerIndex\r\n\t\t})\r\n\t})\r\n\r\n\tfor (const [handRank, playersWhoHoldThisRank] of rankMap) {\r\n\t\tif (playersWhoHoldThisRank.length > 0) {\r\n\t\t\t// only one player can have Royal Flush so they would win regardless of the rest\r\n\t\t\tif (handRank === 'Royal Flush') {\r\n\t\t\t\tconst formattedPlayersWhoHoldThisRank = playersWhoHoldThisRank.map(player => ({\r\n\t\t\t\t\tname: player.name,\r\n\t\t\t\t\tbestHand: player.bestHand,\r\n\t\t\t\t\thandRank\r\n\t\t\t\t}))\r\n\t\t\t\thierarchy = hierarchy.concat(formattedPlayersWhoHoldThisRank);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// if only one player has a ranking that player is the best for that ranking\r\n\t\t\tif (playersWhoHoldThisRank.length === 1) {\r\n\t\t\t\tconst { name, bestHand } = playersWhoHoldThisRank[0];\r\n\t\t\t\thierarchy = hierarchy.concat([{\r\n\t\t\t\t\tname,\r\n\t\t\t\t\tbestHand,\r\n\t\t\t\t\thandRank\r\n\t\t\t\t}]);\r\n\t\t\t\t// if more than one player has same ranking must find which one has higher value\r\n\t\t\t} else if (playersWhoHoldThisRank.length > 1) {\r\n\t\t\t\tconst sortedComparator = createRankingsComparator(handRank, playersWhoHoldThisRank)\r\n\t\t\t\t\t.map((snapshot) => {\r\n\t\t\t\t\t\treturn snapshot.sort((a, b) => b.card.value - a.card.value)\r\n\t\t\t\t\t});\r\n\t\t\t\tconst winnerHierarchy = determinePlayerHandsHierarchy(sortedComparator, handRank);\r\n\t\t\t\thierarchy = hierarchy.concat(winnerHierarchy);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn hierarchy;\r\n}\r\n\r\n\r\n\r\n/*\r\n  Handle and get snapshot with winners and losers of hand\r\n */\r\nconst handleSnapshotFrame = (frame) => {\r\n\tconst highValue = frame[0].card.value;\r\n\tconst winningFrame = frame.filter(snapshot => snapshot.card.value === highValue);\r\n\tconst losingFrame = frame.filter(snapshot => snapshot.card.value < highValue);\r\n\treturn { winningFrame, losingFrame }\r\n}\r\n\r\n/*\r\nGet cards dealt to a player\r\n*/\r\nconst getCards = (deck, numToGet) => {\r\n\t// make shallow copy of deck to not alter original deck attributes\r\n\tconst mutableDeckCopy = [...deck];\r\n\tlet chosenCards;\r\n\tif (numToGet === 1) {\r\n\t\t// get last card \r\n\t\tchosenCards = mutableDeckCopy.pop();\r\n\t} else {\r\n\t\t// get chosen cards from mutable deck copy one by one\r\n\t\tchosenCards = [];\r\n\t\tfor (let i = 0; i < numToGet; i++) {\r\n\t\t\tchosenCards.push(mutableDeckCopy.pop());\r\n\t\t}\r\n\t}\r\n\treturn { mutableDeckCopy, chosenCards }\r\n}\r\n\r\n/*\r\n  Assign winnings to hand winners (handles pot splits too)\r\n */\r\nconst assignWinnings = (state, rankMap, prize) => {\r\n\tlet winnerFound = false;\r\n\r\n\t// find hand winners\r\n\trankMap.forEach((contestants, rank, map) => {\r\n\t\tif (!winnerFound) {\r\n\t\t\t// if only one player active in hand they win\r\n\t\t\tif (contestants.length === 1) {\r\n\t\t\t\twinnerFound = true\r\n\t\t\t\tconsole.log(\"Winner, \", contestants[0].name, \" , beating out the competition with a \", rank)\r\n\t\t\t\tstate = payWinnings(state, contestants, prize, rank)\r\n\t\t\t\t// if more than one player active in hand find winner\r\n\t\t\t} else if (contestants.length > 1) {\r\n\t\t\t\tconsole.log(contestants)\r\n\t\t\t\twinnerFound = true\r\n\t\t\t\t// get active players hand rankings\r\n\t\t\t\tconst winners = findHandWinner(createRankingsComparator(rank, contestants), rank)\r\n\t\t\t\t// if only one player wins they get all the pot\r\n\t\t\t\tif (winners.length === 1) {\r\n\t\t\t\t\tconsole.log(\"Winner, \", winners[0].name, \" , beating out the competition with a \", rank)\r\n\t\t\t\t\tstate = payWinnings(state, winners, prize, rank)\r\n\t\t\t\t\t// if multilple players win the pot is split amongst them\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(\"We have a tie! Split the pot amongst \", winners, \" Who will take the pot with their \", rank)\r\n\t\t\t\t\tstate = payWinnings(state, winners, prize, rank)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Assign side pots when there are multiple winners for the same hand\r\n */\r\nconst assignSidePots = (state) => {\r\n\t// find winners of hand\r\n\tstate.playerHierarchy = buildPlayerRankings(state);\r\n\tconsole.log(\"Ultimate Player Hierarchy Determined:\")\r\n\tconsole.log(state.playerHierarchy);\r\n\r\n\t// assign each side pot to the corresponding winner\r\n\tfor (let sidePot of state.sidePots) {\r\n\t\tconst rankMap = rankPlayersHands(state, sidePot.contestants);\r\n\t\tstate = assignWinnings(state, rankMap, sidePot.potValue)\r\n\t}\r\n\r\n\tstate.players = state.players.map(player => ({\r\n\t\t...player,\r\n\t\troundEndChips: player.chips\r\n\t}));\r\n\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Pay winnings to hand winners\r\n */\r\nconst payWinnings = (state, winners, prize, rank) => {\r\n\t// if only one winner they win all the pot\r\n\tif (winners.length === 1) {\r\n\t\tstate.showDownMessages = state.showDownMessages.concat([{\r\n\t\t\tusers: [winners[0].name],\r\n\t\t\tprize,\r\n\t\t\trank\r\n\t\t}]);\r\n\t\tconsole.log(\"Transferring \", prize, \" chips to \", winners[0].name)\r\n\t\tstate.players[winners[0].playerIndex].chips += prize\r\n\t\tstate.pot -= prize\r\n\t\t// if more than one winner split pot accordingly between them\r\n\t} else if (winners.length > 1) {\r\n\t\tconst overflow = prize % winners.length;\r\n\t\tconst splitPot = Math.floor(prize / winners.length)\r\n\t\tconsole.log(\"Mediating Tie. Total Prize \", prize, \" split into \", winners.length, \" portions with an overflow of \", overflow)\r\n\t\tstate.showDownMessages = state.showDownMessages.concat([{\r\n\t\t\tusers: winners.map(winner => winner.name),\r\n\t\t\tprize: splitPot,\r\n\t\t\trank\r\n\t\t}])\r\n\t\twinners.forEach(winner => {\r\n\t\t\tstate.players[winner.playerIndex].chips += splitPot\r\n\t\t\tstate.pot -= splitPot\r\n\t\t})\r\n\t}\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Create hand rankings comparator to compare hand rankings\r\n */\r\nconst createRankingsComparator = (rank, playerData) => {\r\n\tlet comparator;\r\n\tswitch (rank) {\r\n\t\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\t\tcase ('Royal Flush'): {\r\n\t\t\tcomparator = Array.from({ length: 1 });\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator.push({\r\n\t\t\t\t\t// there can only be one royal flush which will be the winner regardless of other hand rankings\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is four cards all of the same denomination\r\n\t\tcase ('Four Of A Kind'): {\r\n\t\t\tcomparator = Array.from({ length: 2 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// four cards all of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// last card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\tcase ('Full House'): {\r\n\t\t\tcomparator = Array.from({ length: 2 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// three cards of one denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// two cards of another denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\t// or if all five cards are unmatched\r\n\t\tcase ('Flush'):\r\n\t\tcase ('No Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 5 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tfor (let i = 0; i < 5; i++) {\r\n\t\t\t\t\tcomparator[i].push({\r\n\t\t\t\t\t\t// check all 5 cards of a flush or no-pair\r\n\t\t\t\t\t\tcard: playerData[index].bestHand[i],\r\n\t\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tcase ('Three Of A Kind'): {\r\n\t\t\tcomparator = Array.from({ length: 3 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// three cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// fourth card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fifth card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is five cards of any suit in sequence\r\n\t\t// or if hand is five cards in sequence (all of same suit)\r\n\t\tcase ('Straight'):\r\n\t\tcase ('Straight Flush'): {\r\n\t\t\tcomparator = Array.from({ length: 1 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// check highest card of a straight as it will determine the straight value\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is two sets of two cards of the same denomination and any fifth card\r\n\t\tcase ('Two Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 3 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// another two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[2],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fifth unmatched card\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tcase ('Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 4 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// third unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[2],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fourth unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[3].push({\r\n\t\t\t\t\t// fifth unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tdefault: throw Error('Recieved unfamiliar rank argument in createRankingsComparator()');\r\n\t}\r\n\treturn comparator\r\n}\r\n\r\n/*\r\n  Find current hand winner\r\n */\r\nconst findHandWinner = (comparator, rank) => {\r\n\tlet winners;\r\n\tif (rank === 'Royal Flush') return comparator\r\n\tfor (let i = 0; i < comparator.length; i++) {\r\n\t\tlet highValue = 0;\r\n\t\tlet losers = [];\r\n\t\t// sort player rankings comparator \r\n\t\twinners = comparator[i].sort((a, b) => b.card.value - a.card.value).reduce((acc, cur, index) => {\r\n\t\t\t// add player with higher ranking hands first\r\n\t\t\tif (cur.card.value > highValue) {\r\n\r\n\t\t\t\thighValue = cur.card.value;\r\n\t\t\t\tacc.push({\r\n\t\t\t\t\tname: cur.name,\r\n\t\t\t\t\tplayerIndex: cur.playerIndex,\r\n\t\t\t\t});\r\n\t\t\t\treturn acc;\r\n\t\t\t} else if (cur.card.value === highValue) {\r\n\t\t\t\tacc.push({\r\n\t\t\t\t\tname: cur.name,\r\n\t\t\t\t\tplayerIndex: cur.playerIndex,\r\n\t\t\t\t});\r\n\t\t\t\treturn acc;\r\n\t\t\t\t// then add non active players (back of list)\r\n\t\t\t} else if (cur.card.value < highValue) {\r\n\t\t\t\tlosers.push(cur.name);\r\n\t\t\t\treturn acc;\r\n\t\t\t}\r\n\t\t}, [])\r\n\r\n\t\tif (winners.length === 1 || i === comparator.length) {\r\n\t\t\treturn winners\r\n\t\t} else {\r\n\t\t\tif (losers.length >= 1) {\r\n\t\t\t\tlosers.forEach((nameToExtract) => {\r\n\t\t\t\t\tcomparator = comparator.map(snapshot => snapshot.filter((el) => el.name !== nameToExtract));\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn winners\r\n\r\n}\r\n\r\n/*\r\n  Check if hand is a Flush\r\n */\r\nconst checkIfFlush = (suitHistogram) => {\r\n\tlet isFlush;\r\n\tlet flushedSuit;\r\n\t// check if all five cards have the same suit\r\n\tfor (let suit in suitHistogram) {\r\n\t\tif (suitHistogram[suit] >= 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisFlush: true,\r\n\t\t\t\tflushedSuit: suit,\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\tisFlush: false,\r\n\t\tflushedSuit: null,\r\n\t}\r\n}\r\n/*\r\n  Check if hand is straight with Ace, two, three, four, five\r\n */\r\nconst checkIfLowerStraight = (valueSetCopy) => {\r\n\tlet numConcurrentCards = 0;\r\n\tlet concurrentCardValuesLow = [];\r\n\t// Convert Ace which has highest value of 13 to lowest value 0 from which straight would start\r\n\tvalueSetCopy[0] = 0;\r\n\t// sort card values\r\n\tconst sortedValueSetCopy = valueSetCopy.map(el => el).sort((a, b) => a - b);\r\n\t// check if Ace, two, three, four, five are found\r\n\tfor (let i = 1; i < 5; i++) {\r\n\t\tif (numConcurrentCards >= 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisLowStraight: true,\r\n\t\t\t\tconcurrentCardValuesLow,\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((sortedValueSetCopy[i] - sortedValueSetCopy[i - 1]) === 1) {\r\n\t\t\tif (numConcurrentCards === 0) {\r\n\t\t\t\tnumConcurrentCards = 2;\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i - 1]);\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i]);\r\n\t\t\t} else {\r\n\t\t\t\tnumConcurrentCards++;\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnumConcurrentCards = 0;\r\n\t\t\tconcurrentCardValuesLow = [];\r\n\t\t}\r\n\t}\r\n\tif (numConcurrentCards >= 5) {\r\n\t\treturn {\r\n\t\t\tisLowStraight: true,\r\n\t\t\tconcurrentCardValuesLow,\r\n\t\t}\r\n\t} else {\r\n\t\treturn {\r\n\t\t\tisLowStraight: false,\r\n\t\t\tconcurrentCardValuesLow,\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n  Check if hand is a Royal Flush\r\n */\r\nconst checkIfRoyalFlush = (flushMatchCards) => {\r\n\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\tif ((flushMatchCards[0].value === 13) &&\r\n\t\t(flushMatchCards[1].value === 12) &&\r\n\t\t(flushMatchCards[2].value === 11) &&\r\n\t\t(flushMatchCards[3].value === 10) &&\r\n\t\t(flushMatchCards[4].value === 10)) {\r\n\t\treturn true\r\n\t} else { return false }\r\n}\r\n\r\n/*\r\n  Check if hand is a Straight\r\n */\r\nconst checkIfStraight = (valueSet) => {\r\n\t// if less than five cards are valuable to the hand it is not a straight\r\n\tif (valueSet.length < 5) return false\r\n\tlet numConcurrentCards = 0;\r\n\tlet concurrentCardValues = [];\r\n\t// check if hand is five cards of any suit in sequence\r\n\tfor (let i = 1; i < valueSet.length; i++) {\r\n\t\tif (numConcurrentCards === 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisStraight: true,\r\n\t\t\t\tconcurrentCardValues\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((valueSet[i] - valueSet[i - 1]) === -1) {\r\n\t\t\tif (numConcurrentCards === 0) {\r\n\t\t\t\tnumConcurrentCards = 2;\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i - 1]);\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i]);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tnumConcurrentCards++;\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnumConcurrentCards = 0;\r\n\t\t\tconcurrentCardValues = [];\r\n\t\t}\r\n\t}\r\n\tif (numConcurrentCards >= 5) {\r\n\t\treturn {\r\n\t\t\tisStraight: true,\r\n\t\t\tconcurrentCardValues\r\n\t\t}\r\n\t} else {\r\n\t\t// check if is straight with Ace, two, three, four, five\r\n\t\tif (valueSet[0] === 13) {\r\n\t\t\tlet { isLowStraight, concurrentCardValuesLow } = checkIfLowerStraight(cloneDeep(valueSet));\r\n\r\n\t\t\tif (isLowStraight) return {\r\n\t\t\t\tisStraight: true,\r\n\t\t\t\tisLowStraight,\r\n\t\t\t\tconcurrentCardValues,\r\n\t\t\t\tconcurrentCardValuesLow,\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tisStraight: false,\r\n\t\t\tisLowStraight: false,\r\n\t\t\tconcurrentCardValues,\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n  Check if hand is a Straight Flush\r\n */\r\nconst checkIfStraightFlush = (flushMatchCards) => {\r\n\t// check if hand is five cards in sequence (all of same suit)\r\n\tconst valueSet = generateValueSet(flushMatchCards);\r\n\tconst { isStraight, isLowStraight, concurrentCardValues, concurrentCardValuesLow } = checkIfStraight(valueSet);\r\n\treturn {\r\n\t\tisStraightFlush: isStraight,\r\n\t\tisLowStraightFlush: isLowStraight,\r\n\t\tconcurrentSFCardValues: concurrentCardValues,\r\n\t\tconcurrentSFCardValuesLow: concurrentCardValuesLow,\r\n\t}\r\n}\r\n\r\n/*\r\n  Perform player showdown at end of hand\r\n */\r\n  const playerShowDown = (state) => {\r\n\t// find players that are still in the hand\r\n\tfor (let player of state.players) {\r\n\t\tconst frequencyHistogram = {};\r\n\t\tconst suitHistogram = {};\r\n\r\n\t\t// build each player's best hand\r\n\t\tplayer.showDownHand.hand = player.cards.concat(state.communityCards);\r\n\t\tplayer.showDownHand.descendingSortHand = player.showDownHand.hand.map(el => el).sort((a, b) => b.value - a.value); // This mutates showDownHand.hand in place(!!)\r\n\r\n\t\tplayer.showDownHand.descendingSortHand.forEach(card => {\r\n\t\t\tfrequencyHistogram[card.cardFace] = (frequencyHistogram[card.cardFace] + 1 || 1);\r\n\t\t\tsuitHistogram[card.suit] = (suitHistogram[card.suit] + 1 || 1);\r\n\t\t})\r\n\r\n\t\tplayer.frequencyHistogram = frequencyHistogram;\r\n\t\tplayer.suitHistogram = suitHistogram;\r\n\r\n\t\tconst valueSet = generateValueSet(player.showDownHand.descendingSortHand);\r\n\r\n\t\t// check value of each player's hand\r\n\t\tconst { isFlush, flushedSuit } = checkIfFlush(suitHistogram);\r\n\t\tconst flushCards = (isFlush) && player.showDownHand.descendingSortHand.filter(card => card.suit === flushedSuit);\r\n\t\tconst isRoyalFlush = (isFlush) && checkIfRoyalFlush(flushCards);\r\n\t\tconst { isStraightFlush, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow } = (isFlush) && checkIfStraightFlush(flushCards)\r\n\t\tconst { isStraight, isLowStraight, concurrentCardValues, concurrentCardValuesLow } = checkIfStraight(valueSet);\r\n\t\tconst { isFourOfAKind, isFullHouse, isThreeOfAKind, isTwoPair, isPair, frequencyHistogramMetaData } = checkFrequencyHistogram(player.showDownHand.descendingSortHand, frequencyHistogram);\r\n\t\tconst isNoPair = ((!isRoyalFlush) && (!isStraightFlush) && (!isFourOfAKind) && (!isFullHouse) && (!isFlush) && (!isStraight) && (!isThreeOfAKind) && (!isTwoPair) && (!isPair))\r\n\r\n\t\t// set value of each player's hand\r\n\t\tplayer.showDownHand.bools = {\r\n\t\t\tisRoyalFlush,\r\n\t\t\tisStraightFlush,\r\n\t\t\tisFourOfAKind,\r\n\t\t\tisFullHouse,\r\n\t\t\tisFlush,\r\n\t\t\tisStraight,\r\n\t\t\tisThreeOfAKind,\r\n\t\t\tisTwoPair,\r\n\t\t\tisPair,\r\n\t\t\tisNoPair,\r\n\t\t}\r\n\r\n\t\tplayer.showDownHand.heldRankHierarchy = [{\r\n\t\t\tname: 'Royal Flush',\r\n\t\t\tmatch: isRoyalFlush,\r\n\t\t}, {\r\n\t\t\tname: 'Straight Flush',\r\n\t\t\tmatch: isStraightFlush\r\n\t\t}, {\r\n\t\t\tname: 'Four Of A Kind',\r\n\t\t\tmatch: isFourOfAKind,\r\n\t\t}, {\r\n\t\t\tname: 'Full House',\r\n\t\t\tmatch: isFullHouse,\r\n\t\t}, {\r\n\t\t\tname: 'Flush',\r\n\t\t\tmatch: isFlush,\r\n\t\t}, {\r\n\t\t\tname: 'Straight',\r\n\t\t\tmatch: isStraight,\r\n\t\t}, {\r\n\t\t\tname: 'Three Of A Kind',\r\n\t\t\tmatch: isThreeOfAKind,\r\n\t\t}, {\r\n\t\t\tname: 'Two Pair',\r\n\t\t\tmatch: isTwoPair,\r\n\t\t}, {\r\n\t\t\tname: 'Pair',\r\n\t\t\tmatch: isPair,\r\n\t\t}, {\r\n\t\t\tname: 'No Pair',\r\n\t\t\tmatch: isNoPair\r\n\t\t}];\r\n\r\n\t\tplayer.metaData = frequencyHistogramMetaData\r\n\r\n\t\t// get best hand between players in showdown\r\n\t\tconst highRankPosition = player.showDownHand.heldRankHierarchy.findIndex(el => el.match === true);\r\n\t\tplayer.showDownHand.bestHandRank = player.showDownHand.heldRankHierarchy[highRankPosition].name;\r\n\t\tplayer.showDownHand.bestHand = findBestHand(player.showDownHand.descendingSortHand, player.showDownHand.bestHandRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData)\r\n\r\n\t}\r\n\r\n\treturn assignSidePots(state)\r\n\r\n}\r\n\r\n/*\r\n  Check how many hand rankings have occured and with what frequence \r\n  and order\r\n */\r\nconst checkFrequencyHistogram = (hand, frequencyHistogram) => {\r\n\r\n\t// set hand rankings to not seen \r\n\tlet isFourOfAKind = false;\r\n\tlet isFullHouse = false\r\n\tlet isThreeOfAKind = false;\r\n\tlet isTwoPair = false;\r\n\tlet isPair = false;\r\n\tlet numTripples = 0;\r\n\tlet numPairs = 0;\r\n\tlet frequencyHistogramMetaData = {\r\n\t\tpairs: [],\r\n\t\ttripples: [],\r\n\t\tquads: [],\r\n\t}\r\n\t// check if hand is four cards all of the same denomination\r\n\tfor (let cardFace in frequencyHistogram) {\r\n\t\tif (frequencyHistogram[cardFace] === 4) {\r\n\t\t\tisFourOfAKind = true\r\n\t\t\tfrequencyHistogramMetaData.quads.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tif (frequencyHistogram[cardFace] === 3) {\r\n\t\t\tisThreeOfAKind = true\r\n\t\t\tnumTripples++\r\n\t\t\tfrequencyHistogramMetaData.tripples.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tif (frequencyHistogram[cardFace] === 2) {\r\n\t\t\tisPair = true\r\n\t\t\tnumPairs++\r\n\t\t\tfrequencyHistogramMetaData.pairs.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t// sort histogram from best hand to worst hand\r\n\tfrequencyHistogramMetaData.pairs = frequencyHistogramMetaData.pairs.map(el => el).sort((a, b) => b.value - a.value)\r\n\tfrequencyHistogramMetaData.tripples = frequencyHistogramMetaData.tripples.map(el => el).sort((a, b) => b.value - a.value)\r\n\tfrequencyHistogramMetaData.quads = frequencyHistogramMetaData.quads.map(el => el).sort((a, b) => b.value - a.value)\r\n\r\n\t// check if hand is three cards of one denomination and two cards of another denomination (full house)\r\n\tif ((numTripples >= 2) || (numPairs >= 1 && numTripples >= 1)) {\r\n\t\tisFullHouse = true\r\n\t}\r\n\t// check if hand is two sets of two cards of the same denomination and any fifth card (Two Pairs)\r\n\tif (numPairs >= 2) {\r\n\t\tisTwoPair = true\r\n\t}\r\n\r\n\treturn {\r\n\t\tisFourOfAKind,\r\n\t\tisFullHouse,\r\n\t\tisThreeOfAKind,\r\n\t\tisTwoPair,\r\n\t\tisPair,\r\n\t\tfrequencyHistogramMetaData\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nexport { makeDeckOfCards, shuffleCards, dealPlayerCards, getCards, dealFlopCards, dealTurnCards, dealRiverCards, dealOtherCommunityCards, playerShowDown, checkIfFlush, checkIfRoyalFlush, checkIfStraightFlush, checkIfStraight, checkFrequencyHistogram, generateValueSet };\r\n\r\n"]},"metadata":{},"sourceType":"module"}