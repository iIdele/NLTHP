{"ast":null,"code":"/* eslint complexity: \"off\", max-statements: \"off\", max-depth: \"off\" */\nimport { getUpdatedValues } from './utils'; // default mode\n\nexport function mode1(curr, next) {\n  return next;\n} // prevent duplicate values and crossing\n\nexport function mode2(curr, next) {\n  for (var i = 0; i < curr.length; i++) {\n    if (curr[i].key !== next[i].key) {\n      return curr;\n    }\n\n    if (next[i + 1] && next[i].val === next[i + 1].val) {\n      return curr;\n    }\n  }\n\n  return next;\n} // pushable mode\n\nexport function mode3(curr, next, step, reversed, getValue) {\n  var indexForMovingHandle = -1;\n  var handleMoveIsPositive = true;\n\n  for (var i = 0; i < curr.length; i++) {\n    var c = curr[i];\n    var n = next[i]; // make sure keys are in same order if not return curr\n\n    if (!n || n.key !== c.key) {\n      return curr;\n    } else if (n.val !== c.val) {\n      indexForMovingHandle = i;\n      handleMoveIsPositive = n.val - c.val > 0;\n    }\n  } // nothing has changed (shouldn't happen but just in case).\n\n\n  if (indexForMovingHandle === -1) {\n    return curr;\n  } else {\n    var increment = handleMoveIsPositive ? step : -step;\n\n    for (var _i = 0; _i < next.length; _i++) {\n      var n0 = next[_i];\n      var n1 = next[_i + 1];\n\n      if (n1 && n0.val === n1.val) {\n        if (_i === indexForMovingHandle) {\n          var newStep = n1.val + increment;\n\n          if (getValue(newStep) === newStep) {\n            var clone = getUpdatedValues(next, n1.key, n1.val + increment, reversed);\n            var check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        } else {\n          var _newStep = n0.val + increment;\n\n          if (getValue(_newStep) === _newStep) {\n            var _clone = getUpdatedValues(next, n0.key, n0.val + increment, reversed);\n\n            var _check = mode3(next, _clone, step, reversed, getValue);\n\n            if (_check === next) {\n              return curr;\n            } else {\n              return _check;\n            }\n          } else {\n            return curr;\n          }\n        }\n      }\n    }\n  }\n\n  return next;\n}","map":{"version":3,"sources":["C:/Users/manny/fyp/node_modules/react-compound-slider/es/Slider/modes.js"],"names":["getUpdatedValues","mode1","curr","next","mode2","i","length","key","val","mode3","step","reversed","getValue","indexForMovingHandle","handleMoveIsPositive","c","n","increment","_i","n0","n1","newStep","clone","check","_newStep","_clone","_check"],"mappings":"AAAA;AACA,SAASA,gBAAT,QAAiC,SAAjC,C,CAEA;;AACA,OAAO,SAASC,KAAT,CAAeC,IAAf,EAAqBC,IAArB,EAA2B;AAChC,SAAOA,IAAP;AACD,C,CAED;;AACA,OAAO,SAASC,KAAT,CAAeF,IAAf,EAAqBC,IAArB,EAA2B;AAChC,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,QAAIH,IAAI,CAACG,CAAD,CAAJ,CAAQE,GAAR,KAAgBJ,IAAI,CAACE,CAAD,CAAJ,CAAQE,GAA5B,EAAiC;AAC/B,aAAOL,IAAP;AACD;;AAED,QAAIC,IAAI,CAACE,CAAC,GAAG,CAAL,CAAJ,IAAeF,IAAI,CAACE,CAAD,CAAJ,CAAQG,GAAR,KAAgBL,IAAI,CAACE,CAAC,GAAG,CAAL,CAAJ,CAAYG,GAA/C,EAAoD;AAClD,aAAON,IAAP;AACD;AACF;;AAED,SAAOC,IAAP;AACD,C,CAED;;AACA,OAAO,SAASM,KAAT,CAAeP,IAAf,EAAqBC,IAArB,EAA2BO,IAA3B,EAAiCC,QAAjC,EAA2CC,QAA3C,EAAqD;AAC1D,MAAIC,oBAAoB,GAAG,CAAC,CAA5B;AACA,MAAIC,oBAAoB,GAAG,IAA3B;;AAEA,OAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,QAAIU,CAAC,GAAGb,IAAI,CAACG,CAAD,CAAZ;AACA,QAAIW,CAAC,GAAGb,IAAI,CAACE,CAAD,CAAZ,CAFoC,CAIpC;;AACA,QAAI,CAACW,CAAD,IAAMA,CAAC,CAACT,GAAF,KAAUQ,CAAC,CAACR,GAAtB,EAA2B;AACzB,aAAOL,IAAP;AACD,KAFD,MAEO,IAAIc,CAAC,CAACR,GAAF,KAAUO,CAAC,CAACP,GAAhB,EAAqB;AAC1BK,MAAAA,oBAAoB,GAAGR,CAAvB;AACAS,MAAAA,oBAAoB,GAAGE,CAAC,CAACR,GAAF,GAAQO,CAAC,CAACP,GAAV,GAAgB,CAAvC;AACD;AACF,GAfyD,CAiB1D;;;AACA,MAAIK,oBAAoB,KAAK,CAAC,CAA9B,EAAiC;AAC/B,WAAOX,IAAP;AACD,GAFD,MAEO;AACL,QAAIe,SAAS,GAAGH,oBAAoB,GAAGJ,IAAH,GAAU,CAACA,IAA/C;;AAEA,SAAK,IAAIQ,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGf,IAAI,CAACG,MAA3B,EAAmCY,EAAE,EAArC,EAAyC;AACvC,UAAIC,EAAE,GAAGhB,IAAI,CAACe,EAAD,CAAb;AACA,UAAIE,EAAE,GAAGjB,IAAI,CAACe,EAAE,GAAG,CAAN,CAAb;;AAEA,UAAIE,EAAE,IAAID,EAAE,CAACX,GAAH,KAAWY,EAAE,CAACZ,GAAxB,EAA6B;AAC3B,YAAIU,EAAE,KAAKL,oBAAX,EAAiC;AAC/B,cAAIQ,OAAO,GAAGD,EAAE,CAACZ,GAAH,GAASS,SAAvB;;AACA,cAAIL,QAAQ,CAACS,OAAD,CAAR,KAAsBA,OAA1B,EAAmC;AACjC,gBAAIC,KAAK,GAAGtB,gBAAgB,CAACG,IAAD,EAAOiB,EAAE,CAACb,GAAV,EAAea,EAAE,CAACZ,GAAH,GAASS,SAAxB,EAAmCN,QAAnC,CAA5B;AACA,gBAAIY,KAAK,GAAGd,KAAK,CAACN,IAAD,EAAOmB,KAAP,EAAcZ,IAAd,EAAoBC,QAApB,EAA8BC,QAA9B,CAAjB;;AAEA,gBAAIW,KAAK,KAAKpB,IAAd,EAAoB;AAClB,qBAAOD,IAAP;AACD,aAFD,MAEO;AACL,qBAAOqB,KAAP;AACD;AACF,WATD,MASO;AACL,mBAAOrB,IAAP;AACD;AACF,SAdD,MAcO;AACL,cAAIsB,QAAQ,GAAGL,EAAE,CAACX,GAAH,GAASS,SAAxB;;AACA,cAAIL,QAAQ,CAACY,QAAD,CAAR,KAAuBA,QAA3B,EAAqC;AACnC,gBAAIC,MAAM,GAAGzB,gBAAgB,CAACG,IAAD,EAAOgB,EAAE,CAACZ,GAAV,EAAeY,EAAE,CAACX,GAAH,GAASS,SAAxB,EAAmCN,QAAnC,CAA7B;;AACA,gBAAIe,MAAM,GAAGjB,KAAK,CAACN,IAAD,EAAOsB,MAAP,EAAef,IAAf,EAAqBC,QAArB,EAA+BC,QAA/B,CAAlB;;AAEA,gBAAIc,MAAM,KAAKvB,IAAf,EAAqB;AACnB,qBAAOD,IAAP;AACD,aAFD,MAEO;AACL,qBAAOwB,MAAP;AACD;AACF,WATD,MASO;AACL,mBAAOxB,IAAP;AACD;AACF;AACF;AACF;AACF;;AAED,SAAOC,IAAP;AACD","sourcesContent":["/* eslint complexity: \"off\", max-statements: \"off\", max-depth: \"off\" */\nimport { getUpdatedValues } from './utils';\n\n// default mode\nexport function mode1(curr, next) {\n  return next;\n}\n\n// prevent duplicate values and crossing\nexport function mode2(curr, next) {\n  for (var i = 0; i < curr.length; i++) {\n    if (curr[i].key !== next[i].key) {\n      return curr;\n    }\n\n    if (next[i + 1] && next[i].val === next[i + 1].val) {\n      return curr;\n    }\n  }\n\n  return next;\n}\n\n// pushable mode\nexport function mode3(curr, next, step, reversed, getValue) {\n  var indexForMovingHandle = -1;\n  var handleMoveIsPositive = true;\n\n  for (var i = 0; i < curr.length; i++) {\n    var c = curr[i];\n    var n = next[i];\n\n    // make sure keys are in same order if not return curr\n    if (!n || n.key !== c.key) {\n      return curr;\n    } else if (n.val !== c.val) {\n      indexForMovingHandle = i;\n      handleMoveIsPositive = n.val - c.val > 0;\n    }\n  }\n\n  // nothing has changed (shouldn't happen but just in case).\n  if (indexForMovingHandle === -1) {\n    return curr;\n  } else {\n    var increment = handleMoveIsPositive ? step : -step;\n\n    for (var _i = 0; _i < next.length; _i++) {\n      var n0 = next[_i];\n      var n1 = next[_i + 1];\n\n      if (n1 && n0.val === n1.val) {\n        if (_i === indexForMovingHandle) {\n          var newStep = n1.val + increment;\n          if (getValue(newStep) === newStep) {\n            var clone = getUpdatedValues(next, n1.key, n1.val + increment, reversed);\n            var check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        } else {\n          var _newStep = n0.val + increment;\n          if (getValue(_newStep) === _newStep) {\n            var _clone = getUpdatedValues(next, n0.key, n0.val + increment, reversed);\n            var _check = mode3(next, _clone, step, reversed, getValue);\n\n            if (_check === next) {\n              return curr;\n            } else {\n              return _check;\n            }\n          } else {\n            return curr;\n          }\n        }\n      }\n    }\n  }\n\n  return next;\n}"]},"metadata":{},"sourceType":"module"}