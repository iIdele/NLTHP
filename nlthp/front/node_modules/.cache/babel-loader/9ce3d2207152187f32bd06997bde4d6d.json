{"ast":null,"code":"import { dealFlopCards, dealRiverCards, dealTurnCards, playerShowDown } from './cardsService.js';\nimport { chooseNextActivePlayer } from './playersService.js';\n/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/\n\nconst calculateBlindIndices = (dealerIndex, numPlayers) => {\n  return {\n    bigBlindIndex: (dealerIndex + 2) % numPlayers,\n    smallBlindIndex: (dealerIndex + 1) % numPlayers\n  };\n};\n\nconst anteUpBlinds = (players, blindIndices, minBet) => {\n  const {\n    bigBlindIndex,\n    smallBlindIndex\n  } = blindIndices;\n  players[bigBlindIndex].bet = minBet;\n  players[bigBlindIndex].chips = players[bigBlindIndex].chips - minBet;\n  players[smallBlindIndex].bet = minBet / 2;\n  players[smallBlindIndex].chips = players[smallBlindIndex].chips - minBet / 2;\n  return players;\n};\n\nconst calculateMinBet = (highBet, playerChipsStack, playerBet) => {\n  const playerTotalChips = playerChipsStack + playerBet;\n\n  if (playerTotalChips < highBet) {\n    return playerTotalChips;\n  } else {\n    return highBet;\n  }\n};\n/* \r\nDetermines the integrity of all bets.\r\n*/\n\n\nconst manageBet = (state, bet, min, max) => {\n  if (bet < min) {\n    state.betInputValue = min;\n    return console.log(\"Invalid Bet\");\n  }\n\n  if (bet > max) {\n    state.betInputValue = max;\n    return console.log(\"Invalid Bet\");\n  }\n\n  if (bet > state.highBet) {\n    // minbet and highbet may be condensed to a single property\n    state.highBet = bet;\n    state.minBet = state.highBet;\n\n    for (let player of state.players) {\n      if (!player.folded || !player.chips === 0) {\n        player.betReconciled = false;\n      }\n    }\n  }\n\n  const activePlayer = state.players[state.activePlayerIndex];\n  const subtractableChips = bet - activePlayer.bet;\n  activePlayer.bet = bet;\n  activePlayer.chips = activePlayer.chips - subtractableChips;\n\n  if (activePlayer.chips === 0) {\n    activePlayer.allIn = true;\n    state.playersAllIn++;\n  }\n\n  activePlayer.betReconciled = true;\n  return chooseNextActivePlayer(state);\n};\n\nconst managePlayerFold = state => {\n  const activePlayer = state.players[state.activePlayerIndex];\n  activePlayer.folded = true;\n  activePlayer.betReconciled = true;\n  state.playersFolded++;\n  state.playersActive--;\n  const nextState = chooseNextActivePlayer(state);\n  return nextState;\n};\n\nconst managePhaseShift = state => {\n  switch (state.phase) {\n    case 'first round':\n      {\n        state.phase = 'flop';\n        return dealFlopCards(remakePot(state));\n      }\n\n    case 'second round':\n      {\n        state.phase = 'turn';\n        return dealTurnCards(remakePot(state));\n      }\n\n    case 'third round':\n      {\n        state.phase = 'river';\n        return dealRiverCards(remakePot(state));\n      }\n\n    case 'fourth round':\n      {\n        state.phase = 'showdown';\n        return playerShowDown(remakePot(state));\n      }\n\n    default:\n      throw Error(\"managePhaseShift() called from non-betting phase\");\n  }\n};\n/* \r\nCombine sidepots into a single pot to save resources.\r\n*/\n\n\nconst remakePot = state => {\n  for (let player of state.players) {\n    state.pot = state.pot + player.bet;\n    player.sidePotStack = player.bet;\n    player.betReconciled = false;\n  } // condense pots as processing each one requires expensive card comparator functions\n\n\n  state = condensePots(calculatePots(state, state.players));\n\n  for (let player of state.players) {\n    player.currentRoundChipsInvested += player.bet;\n    player.bet = 0; // reset all player bets to 0 for the start of the next round\n  }\n\n  state.minBet = 0; // reset markers which control min/max bet validation\n\n  state.highBet = 0;\n  state.betInputValue = 0;\n  return state;\n};\n/* \r\n Determine which players are included in the current pot.\r\n*/\n\n\nconst calculatePots = (state, playerStacks) => {\n  // remove players who did not bet from pot\n  const investedPlayers = playerStacks.filter(player => player.sidePotStack > 0);\n\n  if (investedPlayers.length === 0) {\n    return state;\n  }\n\n  if (investedPlayers.length === 1) {\n    // refund players who bet in excess of pot\n    const playerToRefund = state.players[state.players.findIndex(player => player.name === investedPlayers[0].name)];\n    playerToRefund.chips = playerToRefund.chips + investedPlayers[0].sidePotStack;\n    state.pot -= investedPlayers[0].sidePotStack;\n    return state;\n  } // sort players\n\n\n  const ascBetPlayers = investedPlayers.sort((a, b) => a.sidePotStack - b.sidePotStack);\n  const smallStackValue = ascBetPlayers[0].sidePotStack;\n  const builtSidePot = ascBetPlayers.reduce((acc, cur) => {\n    if (!cur.folded) {\n      acc.contestants.push(cur.name);\n    }\n\n    acc.potValue = acc.potValue + smallStackValue;\n    cur.sidePotStack = cur.sidePotStack - smallStackValue;\n    return acc;\n  }, {\n    contestants: [],\n    potValue: 0\n  });\n  state.sidePots.push(builtSidePot);\n  return calculatePots(state, ascBetPlayers);\n};\n/* \r\n Condenses mutiple pots into a single pot. \r\n*/\n\n\nconst condensePots = state => {\n  if (state.sidePots.length > 1) {\n    for (let i = 0; i < state.sidePots.length; i++) {\n      for (let n = i + 1; n < state.sidePots.length; n++) {\n        if (arrayIdentical(state.sidePots[i].contestants, state.sidePots[n].contestants)) {\n          state.sidePots[i].potValue = state.sidePots[i].potValue + state.sidePots[n].potValue;\n          state.sidePots = state.sidePots.filter((el, index) => index !== n);\n        }\n      }\n    }\n  }\n\n  return state;\n};\n\nconst arrayIdentical = (arr1, arr2) => {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return arr1.map(el => arr2.includes(el)).filter(bool => bool !== true).length !== 0 ? false : true;\n};\n\nexport { calculateBlindIndices, anteUpBlinds, calculateMinBet, manageBet, managePlayerFold, managePhaseShift, remakePot };","map":{"version":3,"sources":["C:/Users/manny/2021-ca400-idelegi2-puzzuos2/src/ui/src/services/betService.js"],"names":["dealFlopCards","dealRiverCards","dealTurnCards","playerShowDown","chooseNextActivePlayer","calculateBlindIndices","dealerIndex","numPlayers","bigBlindIndex","smallBlindIndex","anteUpBlinds","players","blindIndices","minBet","bet","chips","calculateMinBet","highBet","playerChipsStack","playerBet","playerTotalChips","manageBet","state","min","max","betInputValue","console","log","player","folded","betReconciled","activePlayer","activePlayerIndex","subtractableChips","allIn","playersAllIn","managePlayerFold","playersFolded","playersActive","nextState","managePhaseShift","phase","remakePot","Error","pot","sidePotStack","condensePots","calculatePots","currentRoundChipsInvested","playerStacks","investedPlayers","filter","length","playerToRefund","findIndex","name","ascBetPlayers","sort","a","b","smallStackValue","builtSidePot","reduce","acc","cur","contestants","push","potValue","sidePots","i","n","arrayIdentical","el","index","arr1","arr2","map","includes","bool"],"mappings":"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","sourcesContent":["import { dealFlopCards, dealRiverCards, dealTurnCards, playerShowDown } from './cardsService.js';\r\nimport { chooseNextActivePlayer } from './playersService.js';\r\n\r\n/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/\r\n\r\nconst calculateBlindIndices = (dealerIndex, numPlayers) => {\r\n\treturn ({\r\n\t\tbigBlindIndex: (dealerIndex + 2) % numPlayers,\r\n\t\tsmallBlindIndex: (dealerIndex + 1) % numPlayers,\r\n\t});\r\n}\r\n\r\nconst anteUpBlinds = (players, blindIndices, minBet) => {\r\n\tconst { bigBlindIndex, smallBlindIndex } = blindIndices;\r\n\tplayers[bigBlindIndex].bet = minBet;\r\n\tplayers[bigBlindIndex].chips = players[bigBlindIndex].chips - minBet;\r\n\tplayers[smallBlindIndex].bet = minBet / 2;\r\n\tplayers[smallBlindIndex].chips = players[smallBlindIndex].chips - (minBet / 2);\r\n\treturn players\r\n}\r\n\r\nconst calculateMinBet = (highBet, playerChipsStack, playerBet) => {\r\n\tconst playerTotalChips = playerChipsStack + playerBet\r\n\tif (playerTotalChips < highBet) {\r\n\t\treturn playerTotalChips;\r\n\t} else {\r\n\t\treturn highBet;\r\n\t}\r\n}\r\n\r\n/* \r\nDetermines the integrity of all bets.\r\n*/\r\nconst manageBet = (state, bet, min, max) => {\r\n\tif (bet < min) {\r\n\t\tstate.betInputValue = min;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\tif (bet > max) {\r\n\t\tstate.betInputValue = max;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\r\n\tif (bet > state.highBet) {\r\n\t\t// minbet and highbet may be condensed to a single property\r\n\t\tstate.highBet = bet;\r\n\t\tstate.minBet = state.highBet;\r\n\t\tfor (let player of state.players) {\r\n\t\t\tif (!player.folded || !player.chips === 0) {\r\n\t\t\t\tplayer.betReconciled = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tconst subtractableChips = bet - activePlayer.bet;\r\n\tactivePlayer.bet = bet;\r\n\r\n\tactivePlayer.chips = activePlayer.chips - subtractableChips;\r\n\tif (activePlayer.chips === 0) {\r\n\t\tactivePlayer.allIn = true;\r\n\t\tstate.playersAllIn++\r\n\t}\r\n\tactivePlayer.betReconciled = true;\r\n\treturn chooseNextActivePlayer(state)\r\n}\r\n\r\nconst managePlayerFold = (state) => {\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tactivePlayer.folded = true;\r\n\tactivePlayer.betReconciled = true;\r\n\tstate.playersFolded++\r\n\tstate.playersActive--\r\n\r\n\tconst nextState = chooseNextActivePlayer(state)\r\n\treturn nextState\r\n}\r\n\r\nconst managePhaseShift = (state) => {\r\n\tswitch (state.phase) {\r\n\t\tcase ('first round'): {\r\n\t\t\tstate.phase = 'flop';\r\n\t\t\treturn dealFlopCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('second round'): {\r\n\t\t\tstate.phase = 'turn';\r\n\t\t\treturn dealTurnCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('third round'): {\r\n\t\t\tstate.phase = 'river'\r\n\t\t\treturn dealRiverCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('fourth round'): {\r\n\t\t\tstate.phase = 'showdown'\r\n\t\t\treturn playerShowDown(remakePot(state));\r\n\t\t}\r\n\t\tdefault: throw Error(\"managePhaseShift() called from non-betting phase\")\r\n\t}\r\n}\r\n\r\n/* \r\nCombine sidepots into a single pot to save resources.\r\n*/\r\nconst remakePot = (state) => {\r\n\tfor (let player of state.players) {\r\n\r\n\t\tstate.pot = state.pot + player.bet;\r\n\r\n\t\tplayer.sidePotStack = player.bet;\r\n\t\tplayer.betReconciled = false;\r\n\t}\r\n\r\n\t// condense pots as processing each one requires expensive card comparator functions\r\n\tstate = condensePots(calculatePots(state, state.players));\r\n\r\n\tfor (let player of state.players) {\r\n\t\tplayer.currentRoundChipsInvested += player.bet;\r\n\t\tplayer.bet = 0 // reset all player bets to 0 for the start of the next round\r\n\t}\r\n\r\n\tstate.minBet = 0; // reset markers which control min/max bet validation\r\n\tstate.highBet = 0;\r\n\tstate.betInputValue = 0;\r\n\treturn state\r\n}\r\n\r\n/* \r\n Determine which players are included in the current pot.\r\n*/\r\nconst calculatePots = (state, playerStacks) => {\r\n\t// remove players who did not bet from pot\r\n\tconst investedPlayers = playerStacks.filter(player => player.sidePotStack > 0)\r\n\tif (investedPlayers.length === 0) {\r\n\t\treturn state\r\n\t}\r\n\tif (investedPlayers.length === 1) {\r\n\t\t// refund players who bet in excess of pot\r\n\t\tconst playerToRefund = state.players[state.players.findIndex(player => player.name === investedPlayers[0].name)];\r\n\t\tplayerToRefund.chips = playerToRefund.chips + investedPlayers[0].sidePotStack;\r\n\t\tstate.pot -= investedPlayers[0].sidePotStack\r\n\t\treturn state\r\n\t}\r\n\t// sort players\r\n\tconst ascBetPlayers = investedPlayers.sort((a, b) => a.sidePotStack - b.sidePotStack);\r\n\tconst smallStackValue = ascBetPlayers[0].sidePotStack;\r\n\r\n\tconst builtSidePot = ascBetPlayers.reduce((acc, cur) => {\r\n\t\tif (!cur.folded) {\r\n\t\t\tacc.contestants.push(cur.name);\r\n\t\t}\r\n\t\tacc.potValue = acc.potValue + smallStackValue;\r\n\t\tcur.sidePotStack = cur.sidePotStack - smallStackValue;\r\n\t\treturn acc\r\n\t}, {\r\n\t\tcontestants: [],\r\n\t\tpotValue: 0,\r\n\t});\r\n\tstate.sidePots.push(builtSidePot);\r\n\treturn calculatePots(state, ascBetPlayers)\r\n\r\n}\r\n\r\n/* \r\n Condenses mutiple pots into a single pot. \r\n*/\r\nconst condensePots = (state) => {\r\n\tif (state.sidePots.length > 1) {\r\n\t\tfor (let i = 0; i < state.sidePots.length; i++) {\r\n\t\t\tfor (let n = i + 1; n < state.sidePots.length; n++) {\r\n\t\t\t\tif (arrayIdentical(state.sidePots[i].contestants, state.sidePots[n].contestants)) {\r\n\t\t\t\t\tstate.sidePots[i].potValue = state.sidePots[i].potValue + state.sidePots[n].potValue;\r\n\t\t\t\t\tstate.sidePots = state.sidePots.filter((el, index) => index !== n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn state\r\n}\r\n\r\nconst arrayIdentical = (arr1, arr2) => {\r\n\r\n\tif (arr1.length !== arr2.length) {\r\n\t\treturn false\r\n\t}\r\n\treturn arr1.map(el => arr2.includes(el)).filter(bool => bool !== true).length !== 0 ? false : true;\r\n}\r\nexport {\r\n\tcalculateBlindIndices,\r\n\tanteUpBlinds,\r\n\tcalculateMinBet,\r\n\tmanageBet,\r\n\tmanagePlayerFold,\r\n\tmanagePhaseShift,\r\n\tremakePot\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}