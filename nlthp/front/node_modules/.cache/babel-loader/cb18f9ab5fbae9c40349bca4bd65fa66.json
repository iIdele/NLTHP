{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport { choosePhaseStartActivePlayer, manageOverflowIndex } from './playersService.js';\n/**\r\n * cardsService provides key services to the App that\r\n * regard the Poker game cards. Such services include \r\n * shuffling the cards, dealing the cards finding \r\n * the best hand, etc.\r\n */\n\n/*\r\n  Generate the deck of 52 cards \r\n */\n\nconst makeDeckOfCards = () => {\n  const deck = []; // get every combination of suit and value\n\n  for (let suit of suits) {\n    for (let card of cards) {\n      deck.push({\n        cardFace: card,\n        suit: suit,\n        value: VALUE_MAP[card]\n      });\n    }\n  }\n\n  return deck;\n};\n/*\r\n  Shuffle cards to randomize their order\r\n */\n\n\nconst shuffleCards = deck => {\n  let shuffledDeck = new Array(totalNumCards);\n  let filledSlots = [];\n\n  for (let i = 0; i < totalNumCards; i++) {\n    // if all cards except 1 are given \n    if (i === 51) {\n      // assign the last slot to the remaining card\n      const lastSlot = shuffledDeck.findIndex(el => typeof el == 'undefined');\n      shuffledDeck[lastSlot] = deck[i];\n      filledSlots.push(lastSlot);\n    } else {\n      // randomize order of all cards one by one\n      let shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\n\n      while (filledSlots.includes(shuffleToPosition)) {\n        shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\n      }\n\n      shuffledDeck[shuffleToPosition] = deck[i];\n      filledSlots.push(shuffleToPosition);\n    }\n  }\n\n  return shuffledDeck;\n};\n/*\r\n  Deal players cards at start of each hand\r\n */\n\n\nconst dealPlayerCards = state => {\n  state.clearCards = false;\n  let stallAnimation = 0; // deal cards until every player at table has 2\n\n  while (state.players[state.activePlayerIndex].cards.length < 2) {\n    const {\n      mutableDeckCopy,\n      chosenCards\n    } = getCards(state.deck, 1); // add animation delay \n\n    chosenCards.stallAnimation = stallAnimation;\n    stallAnimation = stallAnimation + 250;\n    const newDeck = [...mutableDeckCopy];\n    state.players[state.activePlayerIndex].cards.push(chosenCards);\n    state.deck = newDeck;\n    state.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\n  }\n\n  if (state.players[state.activePlayerIndex].cards.length === 2) {\n    state.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up'); // set first phase of betting\n\n    state.phase = 'first round';\n    return state;\n  }\n};\n/*\r\n  Find random start position for giving cards (assigns dealer chip)\r\n */\n\n\nconst randomStartPosition = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst totalNumCards = 52;\nconst cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\nconst suits = ['Heart', 'Spade', 'Club', 'Diamond']; // start from 2 as A (or 1) is the higest ranking card\n\nconst VALUE_MAP = {\n  2: 1,\n  3: 2,\n  4: 3,\n  5: 4,\n  6: 5,\n  7: 6,\n  8: 7,\n  9: 8,\n  10: 9,\n  J: 10,\n  Q: 11,\n  K: 12,\n  A: 13\n};\n/*\r\n  Deal flop cards\r\n */\n\nconst dealFlopCards = state => {\n  let stallAnimation = 0;\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 3); // deal first 3 chosen flop cards\n\n  for (let card of chosenCards) {\n    // add animation delay \n    card.stallAnimation = stallAnimation;\n    stallAnimation = stallAnimation + 250;\n    state.communityCards.push(card);\n  }\n\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set second phase of betting\n\n  state.phase = 'second round';\n  return state;\n};\n/*\r\n  Deal turn cards\r\n */\n\n\nconst dealTurnCards = state => {\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 1);\n  chosenCards.stallAnimation = 0;\n  state.communityCards.push(chosenCards);\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set third phase of betting\n\n  state.phase = 'third round';\n  return state;\n};\n/*\r\n  Deal river cards\r\n */\n\n\nconst dealRiverCards = state => {\n  const {\n    mutableDeckCopy,\n    chosenCards\n  } = getCards(state.deck, 1);\n  chosenCards.stallAnimation = 0;\n  state.communityCards.push(chosenCards);\n  state.deck = mutableDeckCopy;\n  state = choosePhaseStartActivePlayer(state); // set fourth phase of betting\n\n  state.phase = 'fourth round';\n  return state;\n};\n/*\r\n  Deal table Community cards \r\n */\n\n\nconst dealOtherCommunityCards = state => {\n  // check number of cards left to deal\n  const cardsToPop = 5 - state.communityCards.length;\n\n  if (cardsToPop >= 1) {\n    let stallAnimation = 0;\n    const {\n      mutableDeckCopy,\n      chosenCards\n    } = getShowdownCards(state.deck, cardsToPop);\n\n    for (let card of chosenCards) {\n      card.stallAnimation = stallAnimation;\n      stallAnimation = stallAnimation + 250;\n      state.communityCards.push(card);\n    }\n\n    state.deck = mutableDeckCopy;\n  } // when completed move to showdown phase (phase to check winners of hand)\n\n\n  state.phase = 'showdown';\n  return state;\n};\n/*\r\n  Perform player showdown at end of hand\r\n */\n\n\nconst playerShowDown = state => {\n  // find players that are still in the hand\n  for (let player of state.players) {\n    const frequencyHistogram = {};\n    const suitHistogram = {}; // build each player's best hand\n\n    player.showDownHand.hand = player.cards.concat(state.communityCards);\n    player.showDownHand.descendingSortHand = player.showDownHand.hand.map(el => el).sort((a, b) => b.value - a.value); // This mutates showDownHand.hand in place(!!)\n\n    player.showDownHand.descendingSortHand.forEach(card => {\n      frequencyHistogram[card.cardFace] = frequencyHistogram[card.cardFace] + 1 || 1;\n      suitHistogram[card.suit] = suitHistogram[card.suit] + 1 || 1;\n    });\n    player.frequencyHistogram = frequencyHistogram;\n    player.suitHistogram = suitHistogram;\n    const valueSet = generateValueSet(player.showDownHand.descendingSortHand); // check value of each player's hand\n\n    const {\n      isFlush,\n      flushedSuit\n    } = checkIfFlush(suitHistogram);\n    const flushCards = isFlush && player.showDownHand.descendingSortHand.filter(card => card.suit === flushedSuit);\n    const isRoyalFlush = isFlush && checkIfRoyalFlush(flushCards);\n    const {\n      isStraightFlush,\n      isLowStraightFlush,\n      concurrentSFCardValues,\n      concurrentSFCardValuesLow\n    } = isFlush && checkIfStraightFlush(flushCards);\n    const {\n      isStraight,\n      isLowStraight,\n      concurrentCardValues,\n      concurrentCardValuesLow\n    } = checkIfStraight(valueSet);\n    const {\n      isFourOfAKind,\n      isFullHouse,\n      isThreeOfAKind,\n      isTwoPair,\n      isPair,\n      frequencyHistogramMetaData\n    } = checkFrequencyHistogram(player.showDownHand.descendingSortHand, frequencyHistogram);\n    const isNoPair = !isRoyalFlush && !isStraightFlush && !isFourOfAKind && !isFullHouse && !isFlush && !isStraight && !isThreeOfAKind && !isTwoPair && !isPair; // set value of each player's hand\n\n    player.showDownHand.bools = {\n      isRoyalFlush,\n      isStraightFlush,\n      isFourOfAKind,\n      isFullHouse,\n      isFlush,\n      isStraight,\n      isThreeOfAKind,\n      isTwoPair,\n      isPair,\n      isNoPair\n    };\n    player.showDownHand.heldRankHierarchy = [{\n      name: 'Royal Flush',\n      match: isRoyalFlush\n    }, {\n      name: 'Straight Flush',\n      match: isStraightFlush\n    }, {\n      name: 'Four Of A Kind',\n      match: isFourOfAKind\n    }, {\n      name: 'Full House',\n      match: isFullHouse\n    }, {\n      name: 'Flush',\n      match: isFlush\n    }, {\n      name: 'Straight',\n      match: isStraight\n    }, {\n      name: 'Three Of A Kind',\n      match: isThreeOfAKind\n    }, {\n      name: 'Two Pair',\n      match: isTwoPair\n    }, {\n      name: 'Pair',\n      match: isPair\n    }, {\n      name: 'No Pair',\n      match: isNoPair\n    }];\n    player.metaData = frequencyHistogramMetaData; // get best hand between players in showdown\n\n    const highRankPosition = player.showDownHand.heldRankHierarchy.findIndex(el => el.match === true);\n    player.showDownHand.bestHandRank = player.showDownHand.heldRankHierarchy[highRankPosition].name;\n    player.showDownHand.bestHand = findBestHand(player.showDownHand.descendingSortHand, player.showDownHand.bestHandRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData);\n  }\n\n  return assignSidePots(state);\n};\n/*\r\n  Get cards of players that are part of showdown\r\n */\n\n\nconst getShowdownCards = (deck, numToPop) => {\n  // make shallow copy of deck to not alter original deck attributes\n  const mutableDeckCopy = [...deck];\n  let chosenCards; // get last card \n\n  if (numToPop === 1) {\n    chosenCards = [mutableDeckCopy.pop()];\n  } else {\n    // get chosen cards from mutable deck copy one by one\n    chosenCards = [];\n\n    for (let i = 0; i < numToPop; i++) {\n      chosenCards.push(mutableDeckCopy.pop());\n    }\n  }\n\n  return {\n    mutableDeckCopy,\n    chosenCards\n  };\n};\n/*\r\n  Find best hand amongst players still in a hand\r\n */\n\n\nconst findBestHand = (hand, bestRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData) => {\n  // check if hand matches any value from best to worst (Royal Flush to High Card)\n  switch (bestRank) {\n    // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n    case 'Royal Flush':\n      {\n        return flushCards.slice(0, 5);\n      }\n    // check if hand is five cards in sequence (all of same suit)\n\n    case 'Straight Flush':\n      {\n        if (isLowStraightFlush && concurrentSFCardValues.length < 5) {\n          concurrentSFCardValuesLow[0] = 13;\n          return concurrentSFCardValuesLow.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []).reverse();\n        } else {\n          return concurrentSFCardValues.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []);\n        }\n      }\n    // check if hand is four cards all of the same denomination\n\n    case 'Four Of A Kind':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 4; i++) {\n          const indexOfQuad = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.quads[0].face);\n          bestHand.push(mutableHand[indexOfQuad]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfQuad);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 1));\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n\n    case 'Full House':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        if (frequencyHistogramMetaData.tripples.length > 1) {\n          for (let i = 0; i < 3; i++) {\n            const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n            bestHand.push(mutableHand[indexOfTripple]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n          }\n\n          for (let i = 0; i < 2; i++) {\n            const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[1].face);\n            bestHand.push(mutableHand[indexOfPair]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n          }\n\n          return bestHand;\n        } else {\n          for (let i = 0; i < 3; i++) {\n            const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n            bestHand.push(mutableHand[indexOfTripple]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n          }\n\n          for (let i = 0; i < 2; i++) {\n            const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\n            bestHand.push(mutableHand[indexOfPair]);\n            mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n          }\n\n          return bestHand;\n        }\n      }\n    // check if hand is five cards all of the same suit\n\n    case 'Flush':\n      {\n        return flushCards.slice(0, 5);\n      }\n    // check if hand is five cards of any suit in sequence\n\n    case 'Straight':\n      {\n        if (isLowStraight && concurrentCardValues.length < 5) {\n          concurrentCardValuesLow[0] = 13;\n          return concurrentCardValuesLow.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(hand[hand.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []).reverse();\n        } else {\n          return concurrentCardValues.reduce((acc, cur, index) => {\n            if (index < 5) {\n              acc.push(hand[hand.findIndex(match => match.value === cur)]);\n            }\n\n            return acc;\n          }, []);\n        }\n      }\n    // check if hand is three cards of the same denomination and two unmatched cards\n\n    case 'Three Of A Kind':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 3; i++) {\n          const indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\n          bestHand.push(mutableHand[indexOfTripple]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfTripple);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 2));\n      }\n    // check if hand is two sets of two cards of the same denomination and any fifth card\n\n    case 'Two Pair':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n        }\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[1].face);\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((match, index) => index !== indexOfPair);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 1));\n      }\n    // check if hand is two cards of the same denomination and three unmatched cards\n\n    case 'Pair':\n      {\n        const bestHand = [];\n        let mutableHand = cloneDeep(hand);\n\n        for (let i = 0; i < 2; i++) {\n          const indexOfPair = mutableHand.findIndex(card => card.cardFace === frequencyHistogramMetaData.pairs[0].face); // CONSIDER : \n\n          bestHand.push(mutableHand[indexOfPair]);\n          mutableHand = mutableHand.filter((card, index) => index !== indexOfPair);\n        }\n\n        return bestHand.concat(mutableHand.slice(0, 3));\n      }\n    // check if hand is all five cards are unmatched\n\n    case 'No Pair':\n      {\n        return hand.slice(0, 5);\n      }\n\n    default:\n      throw Error('Recieved unfamiliar rank argument in findBestHand()');\n  }\n};\n/*\r\nGenerate set of five cards that add value to hand\r\n*/\n\n\nconst generateValueSet = hand => {\n  return Array.from(new Set(hand.map(cardInfo => cardInfo.value)));\n};\n/*\r\n  Determine ranking order of players' hands\r\n */\n\n\nconst determinePlayerHandsHierarchy = (sortedComparator, handRank) => {\n  let winnerHierarchy = [];\n  let loserHierarchy = [];\n\n  const processComparator = (comparator, round = 0) => {\n    if (comparator[0].length === 1) {\n      const {\n        name,\n        bestHand\n      } = comparator[0][0];\n      winnerHierarchy = winnerHierarchy.concat([{\n        name,\n        bestHand,\n        handRank\n      }]);\n      return;\n    }\n\n    let filterableComparator = sortedComparator.map(el => el);\n    const frame = comparator[round];\n    const {\n      winningFrame,\n      losingFrame\n    } = handleSnapshotFrame(frame); // find order of players who did not win hand\n\n    if (losingFrame.length > 0) {\n      const lowerTierComparator = filterableComparator.map(frame => {\n        return frame.filter(snapshot => {\n          return losingFrame.some(snapshotToMatchName => {\n            return snapshotToMatchName.name === snapshot.name;\n          });\n        });\n      }); // Push the filtered comparator to the start of the losers queue. \n\n      loserHierarchy = [lowerTierComparator].concat(loserHierarchy);\n    } // if only one winner they are best hand\n\n\n    if (winningFrame.length === 1) {\n      const {\n        name,\n        bestHand\n      } = winningFrame[0];\n      winnerHierarchy = winnerHierarchy.concat([{\n        name,\n        bestHand,\n        handRank\n      }]); // find order of players who won hand if more than one\n    } else if (round === sortedComparator.length - 1) {\n      const filteredWinnerSnapshots = winningFrame.map(snapshot => ({\n        name: snapshot.name,\n        bestHand: snapshot.bestHand,\n        handRank\n      }));\n      winnerHierarchy = winnerHierarchy.concat([filteredWinnerSnapshots]);\n    } else {\n      const higherTierComparator = filterableComparator.map(frame => {\n        return frame.filter(snapshot => {\n          return winningFrame.some(snapshotToMatchName => {\n            return snapshotToMatchName.name === snapshot.name;\n          });\n        });\n      });\n      processComparator(higherTierComparator, round + 1);\n    }\n  };\n\n  const processLowTierComparators = loserHierarchyFrame => {\n    if (loserHierarchy.length > 0) {\n      const loserComparatorToProcess = loserHierarchyFrame[0];\n      loserHierarchy = loserHierarchyFrame.slice(1);\n      processComparator(loserComparatorToProcess);\n      processLowTierComparators(loserHierarchy);\n    }\n  };\n\n  processComparator(sortedComparator);\n  processLowTierComparators(loserHierarchy);\n  return winnerHierarchy;\n};\n/*\r\n  Build ranking of hands of each player still in hand\r\n */\n\n\nconst buildPlayerRankings = state => {\n  // only consider players still active in hand\n  const activePlayers = state.players.filter(player => !player.folded);\n  let hierarchy = []; // map of possible hand rankings\n\n  const rankMap = new Map([['Royal Flush', []], ['Straight Flush', []], ['Four Of A Kind', []], ['Full House', []], ['Flush', []], ['Straight', []], ['Three Of A Kind', []], ['Two Pair', []], ['Pair', []], ['No Pair', []]]); // for each player find rank and add to ranking map\n\n  activePlayers.forEach((player, playerIndex) => {\n    const {\n      name,\n      showDownHand: {\n        bestHandRank,\n        bestHand\n      }\n    } = player;\n    rankMap.get(bestHandRank).push({\n      name,\n      bestHand,\n      playerIndex\n    });\n  });\n\n  for (const [handRank, playersWhoHoldThisRank] of rankMap) {\n    if (playersWhoHoldThisRank.length > 0) {\n      // only one player can have Royal Flush so they would win regardless of the rest\n      if (handRank === 'Royal Flush') {\n        const formattedPlayersWhoHoldThisRank = playersWhoHoldThisRank.map(player => ({\n          name: player.name,\n          bestHand: player.bestHand,\n          handRank\n        }));\n        hierarchy = hierarchy.concat(formattedPlayersWhoHoldThisRank);\n        continue;\n      } // if only one player has a ranking that player is the best for that ranking\n\n\n      if (playersWhoHoldThisRank.length === 1) {\n        const {\n          name,\n          bestHand\n        } = playersWhoHoldThisRank[0];\n        hierarchy = hierarchy.concat([{\n          name,\n          bestHand,\n          handRank\n        }]); // if more than one player has same ranking must find which one has higher value\n      } else if (playersWhoHoldThisRank.length > 1) {\n        const sortedComparator = createRankingsComparator(handRank, playersWhoHoldThisRank).map(snapshot => {\n          return snapshot.sort((a, b) => b.card.value - a.card.value);\n        });\n        const winnerHierarchy = determinePlayerHandsHierarchy(sortedComparator, handRank);\n        hierarchy = hierarchy.concat(winnerHierarchy);\n      }\n    }\n  }\n\n  return hierarchy;\n};\n/*\r\n  Rank hands of players still active in hand\r\n */\n\n\nconst rankPlayersHands = (state, contestants) => {\n  // map of possible hand rankings\n  const rankMap = new Map([['Royal Flush', []], ['Straight Flush', []], ['Four Of A Kind', []], ['Full House', []], ['Flush', []], ['Straight', []], ['Three Of A Kind', []], ['Two Pair', []], ['Pair', []], ['No Pair', []]]);\n\n  for (let contestant of contestants) {\n    const playerIndex = state.players.findIndex(player => player.name === contestant);\n    const player = state.players[playerIndex]; // if player is active in hand\n\n    if (!player.folded) {\n      // rank player hand\n      rankMap.get(player.showDownHand.bestHandRank).push({\n        name: player.name,\n        playerIndex,\n        bestHand: player.showDownHand.bestHand\n      });\n    }\n  }\n\n  return rankMap;\n};\n/*\r\n  Handle and get snapshot with winners and losers of hand\r\n */\n\n\nconst handleSnapshotFrame = frame => {\n  const highValue = frame[0].card.value;\n  const winningFrame = frame.filter(snapshot => snapshot.card.value === highValue);\n  const losingFrame = frame.filter(snapshot => snapshot.card.value < highValue);\n  return {\n    winningFrame,\n    losingFrame\n  };\n};\n/*\r\nGet cards dealt to a player\r\n*/\n\n\nconst getCards = (deck, numToGet) => {\n  // make shallow copy of deck to not alter original deck attributes\n  const mutableDeckCopy = [...deck];\n  let chosenCards;\n\n  if (numToGet === 1) {\n    // get last card \n    chosenCards = mutableDeckCopy.pop();\n  } else {\n    // get chosen cards from mutable deck copy one by one\n    chosenCards = [];\n\n    for (let i = 0; i < numToGet; i++) {\n      chosenCards.push(mutableDeckCopy.pop());\n    }\n  }\n\n  return {\n    mutableDeckCopy,\n    chosenCards\n  };\n};\n/*\r\n  Assign winnings to hand winners (handles pot splits too)\r\n */\n\n\nconst assignWinnings = (state, rankMap, prize) => {\n  let winnerFound = false; // find hand winners\n\n  rankMap.forEach((contestants, rank, map) => {\n    if (!winnerFound) {\n      // if only one player active in hand they win\n      if (contestants.length === 1) {\n        winnerFound = true;\n        console.log(\"Winner, \", contestants[0].name, \" , beating out the competition with a \", rank);\n        state = payWinnings(state, contestants, prize, rank); // if more than one player active in hand find winner\n      } else if (contestants.length > 1) {\n        console.log(contestants);\n        winnerFound = true; // get active players hand rankings\n\n        const winners = findHandWinner(createRankingsComparator(rank, contestants), rank); // if only one player wins they get all the pot\n\n        if (winners.length === 1) {\n          console.log(\"Winner, \", winners[0].name, \" , beating out the competition with a \", rank);\n          state = payWinnings(state, winners, prize, rank); // if multilple players win the pot is split amongst them\n        } else {\n          console.log(\"We have a tie! Split the pot amongst \", winners, \" Who will take the pot with their \", rank);\n          state = payWinnings(state, winners, prize, rank);\n        }\n      }\n    }\n  });\n  return state;\n};\n/*\r\n  Assign side pots when there are multiple winners for the same hand\r\n */\n\n\nconst assignSidePots = state => {\n  // find winners of hand\n  state.playerHierarchy = buildPlayerRankings(state);\n  console.log(\"Ultimate Player Hierarchy Determined:\");\n  console.log(state.playerHierarchy); // assign each side pot to the corresponding winner\n\n  for (let sidePot of state.sidePots) {\n    const rankMap = rankPlayersHands(state, sidePot.contestants);\n    state = assignWinnings(state, rankMap, sidePot.potValue);\n  }\n\n  state.players = state.players.map(player => ({ ...player,\n    roundEndChips: player.chips\n  }));\n  return state;\n};\n/*\r\n  Pay winnings to hand winners\r\n */\n\n\nconst payWinnings = (state, winners, prize, rank) => {\n  // if only one winner they win all the pot\n  if (winners.length === 1) {\n    state.showDownMessages = state.showDownMessages.concat([{\n      users: [winners[0].name],\n      prize,\n      rank\n    }]);\n    console.log(\"Transferring \", prize, \" chips to \", winners[0].name);\n    state.players[winners[0].playerIndex].chips += prize;\n    state.pot -= prize; // if more than one winner split pot accordingly between them\n  } else if (winners.length > 1) {\n    const overflow = prize % winners.length;\n    const splitPot = Math.floor(prize / winners.length);\n    console.log(\"Mediating Tie. Total Prize \", prize, \" split into \", winners.length, \" portions with an overflow of \", overflow);\n    state.showDownMessages = state.showDownMessages.concat([{\n      users: winners.map(winner => winner.name),\n      prize: splitPot,\n      rank\n    }]);\n    winners.forEach(winner => {\n      state.players[winner.playerIndex].chips += splitPot;\n      state.pot -= splitPot;\n    });\n  }\n\n  return state;\n};\n/*\r\n  Create hand rankings comparator to compare hand rankings\r\n */\n\n\nconst createRankingsComparator = (rank, playerData) => {\n  let comparator;\n\n  switch (rank) {\n    // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n    case 'Royal Flush':\n      {\n        comparator = Array.from({\n          length: 1\n        });\n        playerData.forEach((playerShowdownData, index) => {\n          comparator.push({\n            // there can only be one royal flush which will be the winner regardless of other hand rankings\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is four cards all of the same denomination\n\n    case 'Four Of A Kind':\n      {\n        comparator = Array.from({\n          length: 2\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // four cards all of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // last card is unmatched\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n\n    case 'Full House':\n      {\n        comparator = Array.from({\n          length: 2\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // three cards of one denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // two cards of another denomination\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is three cards of one denomination and two cards of another denomination\n    // or if all five cards are unmatched\n\n    case 'Flush':\n    case 'No Pair':\n      {\n        comparator = Array.from({\n          length: 5\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          for (let i = 0; i < 5; i++) {\n            comparator[i].push({\n              // check all 5 cards of a flush or no-pair\n              card: playerData[index].bestHand[i],\n              name: playerData[index].name,\n              playerIndex: playerData[index].playerIndex,\n              bestHand: playerData[index].bestHand\n            });\n          }\n        });\n        break;\n      }\n    // check if hand is three cards of the same denomination and two unmatched cards\n\n    case 'Three Of A Kind':\n      {\n        comparator = Array.from({\n          length: 3\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // three cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // fourth card is unmatched\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fifth card is unmatched\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is five cards of any suit in sequence\n    // or if hand is five cards in sequence (all of same suit)\n\n    case 'Straight':\n    case 'Straight Flush':\n      {\n        comparator = Array.from({\n          length: 1\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // check highest card of a straight as it will determine the straight value\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is two sets of two cards of the same denomination and any fifth card\n\n    case 'Two Pair':\n      {\n        comparator = Array.from({\n          length: 3\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // two cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // another two cards of the same denomination\n            card: playerData[index].bestHand[2],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fifth unmatched card\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n    // check if hand is two cards of the same denomination and three unmatched cards\n\n    case 'Pair':\n      {\n        comparator = Array.from({\n          length: 4\n        }, () => Array.from({\n          length: 0\n        }));\n        playerData.forEach((playerShowdownData, index) => {\n          comparator[0].push({\n            // two cards of the same denomination\n            card: playerData[index].bestHand[0],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[1].push({\n            // third unmtached card\n            card: playerData[index].bestHand[2],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[2].push({\n            // fourth unmtached card\n            card: playerData[index].bestHand[3],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n          comparator[3].push({\n            // fifth unmtached card\n            card: playerData[index].bestHand[4],\n            name: playerData[index].name,\n            playerIndex: playerData[index].playerIndex,\n            bestHand: playerData[index].bestHand\n          });\n        });\n        break;\n      }\n\n    default:\n      throw Error('Recieved unfamiliar rank argument in createRankingsComparator()');\n  }\n\n  return comparator;\n};\n/*\r\n  Find current hand winner\r\n */\n\n\nconst findHandWinner = (comparator, rank) => {\n  let winners;\n  if (rank === 'Royal Flush') return comparator;\n\n  for (let i = 0; i < comparator.length; i++) {\n    let highValue = 0;\n    let losers = []; // sort player rankings comparator \n\n    winners = comparator[i].sort((a, b) => b.card.value - a.card.value).reduce((acc, cur, index) => {\n      // add player with higher ranking hands first\n      if (cur.card.value > highValue) {\n        highValue = cur.card.value;\n        acc.push({\n          name: cur.name,\n          playerIndex: cur.playerIndex\n        });\n        return acc;\n      } else if (cur.card.value === highValue) {\n        acc.push({\n          name: cur.name,\n          playerIndex: cur.playerIndex\n        });\n        return acc; // then add non active players (back of list)\n      } else if (cur.card.value < highValue) {\n        losers.push(cur.name);\n        return acc;\n      }\n    }, []);\n\n    if (winners.length === 1 || i === comparator.length) {\n      return winners;\n    } else {\n      if (losers.length >= 1) {\n        losers.forEach(nameToExtract => {\n          comparator = comparator.map(snapshot => snapshot.filter(el => el.name !== nameToExtract));\n        });\n      }\n    }\n  }\n\n  return winners;\n};\n/*\r\n  Check if hand is a Flush\r\n */\n\n\nconst checkIfFlush = suitHistogram => {\n  let isFlush;\n  let flushedSuit; // check if all five cards have the same suit\n\n  for (let suit in suitHistogram) {\n    if (suitHistogram[suit] >= 5) {\n      return {\n        isFlush: true,\n        flushedSuit: suit\n      };\n    }\n  }\n\n  return {\n    isFlush: false,\n    flushedSuit: null\n  };\n};\n/*\r\n  Check if hand is straight with Ace, two, three, four, five\r\n */\n\n\nconst checkIfLowerStraight = valueSetCopy => {\n  let numConcurrentCards = 0;\n  let concurrentCardValuesLow = []; // Convert Ace which has highest value of 13 to lowest value 0 from which straight would start\n\n  valueSetCopy[0] = 0; // sort card values\n\n  const sortedValueSetCopy = valueSetCopy.map(el => el).sort((a, b) => a - b); // check if Ace, two, three, four, five are found\n\n  for (let i = 1; i < 5; i++) {\n    if (numConcurrentCards >= 5) {\n      return {\n        isLowStraight: true,\n        concurrentCardValuesLow\n      };\n    }\n\n    if (sortedValueSetCopy[i] - sortedValueSetCopy[i - 1] === 1) {\n      if (numConcurrentCards === 0) {\n        numConcurrentCards = 2;\n        concurrentCardValuesLow.push(sortedValueSetCopy[i - 1]);\n        concurrentCardValuesLow.push(sortedValueSetCopy[i]);\n      } else {\n        numConcurrentCards++;\n        concurrentCardValuesLow.push(sortedValueSetCopy[i]);\n      }\n    } else {\n      numConcurrentCards = 0;\n      concurrentCardValuesLow = [];\n    }\n  }\n\n  if (numConcurrentCards >= 5) {\n    return {\n      isLowStraight: true,\n      concurrentCardValuesLow\n    };\n  } else {\n    return {\n      isLowStraight: false,\n      concurrentCardValuesLow\n    };\n  }\n};\n/*\r\n  Check if hand is a Royal Flush\r\n */\n\n\nconst checkIfRoyalFlush = flushMatchCards => {\n  // check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\n  if (flushMatchCards[0].value === 13 && flushMatchCards[1].value === 12 && flushMatchCards[2].value === 11 && flushMatchCards[3].value === 10 && flushMatchCards[4].value === 10) {\n    return true;\n  } else {\n    return false;\n  }\n};\n/*\r\n  Check if hand is a Straight\r\n */\n\n\nconst checkIfStraight = valueSet => {\n  // if less than five cards are valuable to the hand it is not a straight\n  if (valueSet.length < 5) return false;\n  let numConcurrentCards = 0;\n  let concurrentCardValues = []; // check if hand is five cards of any suit in sequence\n\n  for (let i = 1; i < valueSet.length; i++) {\n    if (numConcurrentCards === 5) {\n      return {\n        isStraight: true,\n        concurrentCardValues\n      };\n    }\n\n    if (valueSet[i] - valueSet[i - 1] === -1) {\n      if (numConcurrentCards === 0) {\n        numConcurrentCards = 2;\n        concurrentCardValues.push(valueSet[i - 1]);\n        concurrentCardValues.push(valueSet[i]);\n      } else {\n        numConcurrentCards++;\n        concurrentCardValues.push(valueSet[i]);\n      }\n    } else {\n      numConcurrentCards = 0;\n      concurrentCardValues = [];\n    }\n  }\n\n  if (numConcurrentCards >= 5) {\n    return {\n      isStraight: true,\n      concurrentCardValues\n    };\n  } else {\n    // check if is straight with Ace, two, three, four, five\n    if (valueSet[0] === 13) {\n      let {\n        isLowStraight,\n        concurrentCardValuesLow\n      } = checkIfLowerStraight(cloneDeep(valueSet));\n      if (isLowStraight) return {\n        isStraight: true,\n        isLowStraight,\n        concurrentCardValues,\n        concurrentCardValuesLow\n      };\n    }\n\n    return {\n      isStraight: false,\n      isLowStraight: false,\n      concurrentCardValues\n    };\n  }\n};\n/*\r\n  Check if hand is a Straight Flush\r\n */\n\n\nconst checkIfStraightFlush = flushMatchCards => {\n  // check if hand is five cards in sequence (all of same suit)\n  const valueSet = generateValueSet(flushMatchCards);\n  const {\n    isStraight,\n    isLowStraight,\n    concurrentCardValues,\n    concurrentCardValuesLow\n  } = checkIfStraight(valueSet);\n  return {\n    isStraightFlush: isStraight,\n    isLowStraightFlush: isLowStraight,\n    concurrentSFCardValues: concurrentCardValues,\n    concurrentSFCardValuesLow: concurrentCardValuesLow\n  };\n};\n/*\r\n  Check how many hand rankings have occured and with what frequence \r\n  and order\r\n */\n\n\nconst checkFrequencyHistogram = (hand, frequencyHistogram) => {\n  // set hand rankings to not seen \n  let isFourOfAKind = false;\n  let isFullHouse = false;\n  let isThreeOfAKind = false;\n  let isTwoPair = false;\n  let isPair = false;\n  let numTripples = 0;\n  let numPairs = 0;\n  let frequencyHistogramMetaData = {\n    pairs: [],\n    tripples: [],\n    quads: []\n  }; // check if hand is four cards all of the same denomination\n\n  for (let cardFace in frequencyHistogram) {\n    if (frequencyHistogram[cardFace] === 4) {\n      isFourOfAKind = true;\n      frequencyHistogramMetaData.quads.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    } // check if hand is three cards of the same denomination and two unmatched cards\n\n\n    if (frequencyHistogram[cardFace] === 3) {\n      isThreeOfAKind = true;\n      numTripples++;\n      frequencyHistogramMetaData.tripples.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    } // check if hand is two cards of the same denomination and three unmatched cards\n\n\n    if (frequencyHistogram[cardFace] === 2) {\n      isPair = true;\n      numPairs++;\n      frequencyHistogramMetaData.pairs.push({\n        face: cardFace,\n        value: VALUE_MAP[cardFace]\n      });\n    }\n  } // sort histogram from best hand to worst hand\n\n\n  frequencyHistogramMetaData.pairs = frequencyHistogramMetaData.pairs.map(el => el).sort((a, b) => b.value - a.value);\n  frequencyHistogramMetaData.tripples = frequencyHistogramMetaData.tripples.map(el => el).sort((a, b) => b.value - a.value);\n  frequencyHistogramMetaData.quads = frequencyHistogramMetaData.quads.map(el => el).sort((a, b) => b.value - a.value); // check if hand is three cards of one denomination and two cards of another denomination (full house)\n\n  if (numTripples >= 2 || numPairs >= 1 && numTripples >= 1) {\n    isFullHouse = true;\n  } // check if hand is two sets of two cards of the same denomination and any fifth card (Two Pairs)\n\n\n  if (numPairs >= 2) {\n    isTwoPair = true;\n  }\n\n  return {\n    isFourOfAKind,\n    isFullHouse,\n    isThreeOfAKind,\n    isTwoPair,\n    isPair,\n    frequencyHistogramMetaData\n  };\n};\n\nexport { makeDeckOfCards, shuffleCards, dealPlayerCards, getCards, dealFlopCards, dealTurnCards, dealRiverCards, dealOtherCommunityCards, playerShowDown, checkIfFlush, checkIfRoyalFlush, checkIfStraightFlush, checkIfStraight, checkFrequencyHistogram, generateValueSet };","map":{"version":3,"sources":["C:/Users/manny/2021-ca400-idelegi2-puzzuos2/src/ui/src/services/cardsService.js"],"names":["cloneDeep","choosePhaseStartActivePlayer","manageOverflowIndex","makeDeckOfCards","deck","suit","suits","card","cards","push","cardFace","value","VALUE_MAP","shuffleCards","shuffledDeck","Array","totalNumCards","filledSlots","i","lastSlot","findIndex","el","shuffleToPosition","randomStartPosition","includes","dealPlayerCards","state","clearCards","stallAnimation","players","activePlayerIndex","length","mutableDeckCopy","chosenCards","getCards","newDeck","blindIndex","big","phase","min","max","Math","ceil","floor","random","J","Q","K","A","dealFlopCards","communityCards","dealTurnCards","dealRiverCards","dealOtherCommunityCards","cardsToPop","getShowdownCards","playerShowDown","player","frequencyHistogram","suitHistogram","showDownHand","hand","concat","descendingSortHand","map","sort","a","b","forEach","valueSet","generateValueSet","isFlush","flushedSuit","checkIfFlush","flushCards","filter","isRoyalFlush","checkIfRoyalFlush","isStraightFlush","isLowStraightFlush","concurrentSFCardValues","concurrentSFCardValuesLow","checkIfStraightFlush","isStraight","isLowStraight","concurrentCardValues","concurrentCardValuesLow","checkIfStraight","isFourOfAKind","isFullHouse","isThreeOfAKind","isTwoPair","isPair","frequencyHistogramMetaData","checkFrequencyHistogram","isNoPair","bools","heldRankHierarchy","name","match","metaData","highRankPosition","bestHandRank","bestHand","findBestHand","assignSidePots","numToPop","pop","bestRank","slice","reduce","acc","cur","index","reverse","mutableHand","indexOfQuad","quads","face","tripples","indexOfTripple","indexOfPair","pairs","Error","from","Set","cardInfo","determinePlayerHandsHierarchy","sortedComparator","handRank","winnerHierarchy","loserHierarchy","processComparator","comparator","round","filterableComparator","frame","winningFrame","losingFrame","handleSnapshotFrame","lowerTierComparator","snapshot","some","snapshotToMatchName","filteredWinnerSnapshots","higherTierComparator","processLowTierComparators","loserHierarchyFrame","loserComparatorToProcess","buildPlayerRankings","activePlayers","folded","hierarchy","rankMap","Map","playerIndex","get","playersWhoHoldThisRank","formattedPlayersWhoHoldThisRank","createRankingsComparator","rankPlayersHands","contestants","contestant","highValue","numToGet","assignWinnings","prize","winnerFound","rank","console","log","payWinnings","winners","findHandWinner","playerHierarchy","sidePot","sidePots","potValue","roundEndChips","chips","showDownMessages","users","pot","overflow","splitPot","winner","playerData","playerShowdownData","losers","nameToExtract","checkIfLowerStraight","valueSetCopy","numConcurrentCards","sortedValueSetCopy","flushMatchCards","numTripples","numPairs"],"mappings":"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","sourcesContent":["import { cloneDeep } from 'lodash';\r\nimport { choosePhaseStartActivePlayer, manageOverflowIndex } from './playersService.js';\r\n\r\n/**\r\n * cardsService provides key services to the App that\r\n * regard the Poker game cards. Such services include \r\n * shuffling the cards, dealing the cards finding \r\n * the best hand, etc.\r\n */\r\n\r\n\r\n/*\r\n  Generate the deck of 52 cards \r\n */\r\nconst makeDeckOfCards = () => {\r\n\tconst deck = [];\r\n\r\n\t// get every combination of suit and value\r\n\tfor (let suit of suits) {\r\n\t\tfor (let card of cards) {\r\n\t\t\tdeck.push({\r\n\t\t\t\tcardFace: card,\r\n\t\t\t\tsuit: suit,\r\n\t\t\t\tvalue: VALUE_MAP[card]\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\treturn deck\r\n}\r\n\r\n\r\n/*\r\n  Shuffle cards to randomize their order\r\n */\r\nconst shuffleCards = (deck) => {\r\n\tlet shuffledDeck = new Array(totalNumCards);\r\n\tlet filledSlots = [];\r\n\tfor (let i = 0; i < totalNumCards; i++) {\r\n\t\t// if all cards except 1 are given \r\n\t\tif (i === 51) {\r\n\t\t\t// assign the last slot to the remaining card\r\n\t\t\tconst lastSlot = shuffledDeck.findIndex((el) => typeof el == 'undefined');\r\n\t\t\tshuffledDeck[lastSlot] = deck[i];\r\n\t\t\tfilledSlots.push(lastSlot);\r\n\t\t} else {\r\n\t\t\t// randomize order of all cards one by one\r\n\t\t\tlet shuffleToPosition = randomStartPosition(0, totalNumCards - 1);\r\n\t\t\twhile (filledSlots.includes(shuffleToPosition)) {\r\n\t\t\t\tshuffleToPosition = randomStartPosition(0, totalNumCards - 1);\r\n\t\t\t}\r\n\t\t\tshuffledDeck[shuffleToPosition] = deck[i];\r\n\t\t\tfilledSlots.push(shuffleToPosition);\r\n\t\t}\r\n\t}\r\n\treturn shuffledDeck\r\n}\r\n\r\n\r\n/*\r\n  Deal players cards at start of each hand\r\n */\r\nconst dealPlayerCards = (state) => {\r\n\tstate.clearCards = false;\r\n\tlet stallAnimation = 0;\r\n\t// deal cards until every player at table has 2\r\n\twhile (state.players[state.activePlayerIndex].cards.length < 2) {\r\n\t\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\r\n\t\t// add animation delay \r\n\t\tchosenCards.stallAnimation = stallAnimation;\r\n\t\tstallAnimation = stallAnimation + 250;\r\n\r\n\t\tconst newDeck = [...mutableDeckCopy];\r\n\t\tstate.players[state.activePlayerIndex].cards.push(chosenCards);\r\n\r\n\t\tstate.deck = newDeck;\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\r\n\t}\r\n\tif (state.players[state.activePlayerIndex].cards.length === 2) {\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up');\r\n\t\t// set first phase of betting\r\n\t\tstate.phase = 'first round';\r\n\t\treturn state;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n  Find random start position for giving cards (assigns dealer chip)\r\n */\r\nconst randomStartPosition = (min, max) => {\r\n\tmin = Math.ceil(min);\r\n\tmax = Math.floor(max);\r\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nconst totalNumCards = 52;\r\nconst cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\r\nconst suits = ['Heart', 'Spade', 'Club', 'Diamond'];\r\n\r\n// start from 2 as A (or 1) is the higest ranking card\r\nconst VALUE_MAP = {\r\n\t2: 1,\r\n\t3: 2,\r\n\t4: 3,\r\n\t5: 4,\r\n\t6: 5,\r\n\t7: 6,\r\n\t8: 7,\r\n\t9: 8,\r\n\t10: 9,\r\n\tJ: 10,\r\n\tQ: 11,\r\n\tK: 12,\r\n\tA: 13,\r\n}\r\n\r\n/*\r\n  Deal flop cards\r\n */\r\nconst dealFlopCards = (state) => {\r\n\tlet stallAnimation = 0;\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 3);\r\n\r\n\t// deal first 3 chosen flop cards\r\n\tfor (let card of chosenCards) {\r\n\t\t// add animation delay \r\n\t\tcard.stallAnimation = stallAnimation;\r\n\t\tstallAnimation = stallAnimation + 250;\r\n\t\tstate.communityCards.push(card);\r\n\t}\r\n\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set second phase of betting\r\n\tstate.phase = 'second round';\r\n\r\n\treturn state;\r\n}\r\n\r\n/*\r\n  Deal turn cards\r\n */\r\nconst dealTurnCards = (state) => {\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\tchosenCards.stallAnimation = 0;\r\n\r\n\tstate.communityCards.push(chosenCards);\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set third phase of betting\r\n\tstate.phase = 'third round'\r\n\r\n\treturn state\r\n}\r\n\r\n\r\n/*\r\n  Deal river cards\r\n */\r\nconst dealRiverCards = (state) => {\r\n\tconst { mutableDeckCopy, chosenCards } = getCards(state.deck, 1);\r\n\tchosenCards.stallAnimation = 0;\r\n\r\n\tstate.communityCards.push(chosenCards);\r\n\tstate.deck = mutableDeckCopy;\r\n\tstate = choosePhaseStartActivePlayer(state)\r\n\t// set fourth phase of betting\r\n\tstate.phase = 'fourth round'\r\n\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Deal table Community cards \r\n */\r\nconst dealOtherCommunityCards = (state) => {\r\n\t// check number of cards left to deal\r\n\tconst cardsToPop = 5 - state.communityCards.length\r\n\tif (cardsToPop >= 1) {\r\n\t\tlet stallAnimation = 0;\r\n\t\tconst { mutableDeckCopy, chosenCards } = getShowdownCards(state.deck, cardsToPop);\r\n\r\n\t\tfor (let card of chosenCards) {\r\n\t\t\tcard.stallAnimation = stallAnimation;\r\n\t\t\tstallAnimation = stallAnimation + 250;\r\n\t\t\tstate.communityCards.push(card);\r\n\t\t}\r\n\r\n\t\tstate.deck = mutableDeckCopy;\r\n\t}\r\n\t// when completed move to showdown phase (phase to check winners of hand)\r\n\tstate.phase = 'showdown'\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Perform player showdown at end of hand\r\n */\r\nconst playerShowDown = (state) => {\r\n\t// find players that are still in the hand\r\n\tfor (let player of state.players) {\r\n\t\tconst frequencyHistogram = {};\r\n\t\tconst suitHistogram = {};\r\n\r\n\t\t// build each player's best hand\r\n\t\tplayer.showDownHand.hand = player.cards.concat(state.communityCards);\r\n\t\tplayer.showDownHand.descendingSortHand = player.showDownHand.hand.map(el => el).sort((a, b) => b.value - a.value); // This mutates showDownHand.hand in place(!!)\r\n\r\n\t\tplayer.showDownHand.descendingSortHand.forEach(card => {\r\n\t\t\tfrequencyHistogram[card.cardFace] = (frequencyHistogram[card.cardFace] + 1 || 1);\r\n\t\t\tsuitHistogram[card.suit] = (suitHistogram[card.suit] + 1 || 1);\r\n\t\t})\r\n\r\n\t\tplayer.frequencyHistogram = frequencyHistogram;\r\n\t\tplayer.suitHistogram = suitHistogram;\r\n\r\n\t\tconst valueSet = generateValueSet(player.showDownHand.descendingSortHand);\r\n\r\n\t\t// check value of each player's hand\r\n\t\tconst { isFlush, flushedSuit } = checkIfFlush(suitHistogram);\r\n\t\tconst flushCards = (isFlush) && player.showDownHand.descendingSortHand.filter(card => card.suit === flushedSuit);\r\n\t\tconst isRoyalFlush = (isFlush) && checkIfRoyalFlush(flushCards);\r\n\t\tconst { isStraightFlush, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow } = (isFlush) && checkIfStraightFlush(flushCards)\r\n\t\tconst { isStraight, isLowStraight, concurrentCardValues, concurrentCardValuesLow } = checkIfStraight(valueSet);\r\n\t\tconst { isFourOfAKind, isFullHouse, isThreeOfAKind, isTwoPair, isPair, frequencyHistogramMetaData } = checkFrequencyHistogram(player.showDownHand.descendingSortHand, frequencyHistogram);\r\n\t\tconst isNoPair = ((!isRoyalFlush) && (!isStraightFlush) && (!isFourOfAKind) && (!isFullHouse) && (!isFlush) && (!isStraight) && (!isThreeOfAKind) && (!isTwoPair) && (!isPair))\r\n\r\n\t\t// set value of each player's hand\r\n\t\tplayer.showDownHand.bools = {\r\n\t\t\tisRoyalFlush,\r\n\t\t\tisStraightFlush,\r\n\t\t\tisFourOfAKind,\r\n\t\t\tisFullHouse,\r\n\t\t\tisFlush,\r\n\t\t\tisStraight,\r\n\t\t\tisThreeOfAKind,\r\n\t\t\tisTwoPair,\r\n\t\t\tisPair,\r\n\t\t\tisNoPair,\r\n\t\t}\r\n\r\n\t\tplayer.showDownHand.heldRankHierarchy = [{\r\n\t\t\tname: 'Royal Flush',\r\n\t\t\tmatch: isRoyalFlush,\r\n\t\t}, {\r\n\t\t\tname: 'Straight Flush',\r\n\t\t\tmatch: isStraightFlush\r\n\t\t}, {\r\n\t\t\tname: 'Four Of A Kind',\r\n\t\t\tmatch: isFourOfAKind,\r\n\t\t}, {\r\n\t\t\tname: 'Full House',\r\n\t\t\tmatch: isFullHouse,\r\n\t\t}, {\r\n\t\t\tname: 'Flush',\r\n\t\t\tmatch: isFlush,\r\n\t\t}, {\r\n\t\t\tname: 'Straight',\r\n\t\t\tmatch: isStraight,\r\n\t\t}, {\r\n\t\t\tname: 'Three Of A Kind',\r\n\t\t\tmatch: isThreeOfAKind,\r\n\t\t}, {\r\n\t\t\tname: 'Two Pair',\r\n\t\t\tmatch: isTwoPair,\r\n\t\t}, {\r\n\t\t\tname: 'Pair',\r\n\t\t\tmatch: isPair,\r\n\t\t}, {\r\n\t\t\tname: 'No Pair',\r\n\t\t\tmatch: isNoPair\r\n\t\t}];\r\n\r\n\t\tplayer.metaData = frequencyHistogramMetaData\r\n\r\n\t\t// get best hand between players in showdown\r\n\t\tconst highRankPosition = player.showDownHand.heldRankHierarchy.findIndex(el => el.match === true);\r\n\t\tplayer.showDownHand.bestHandRank = player.showDownHand.heldRankHierarchy[highRankPosition].name;\r\n\t\tplayer.showDownHand.bestHand = findBestHand(player.showDownHand.descendingSortHand, player.showDownHand.bestHandRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData)\r\n\r\n\t}\r\n\r\n\treturn assignSidePots(state)\r\n\r\n}\r\n\r\n/*\r\n  Get cards of players that are part of showdown\r\n */\r\nconst getShowdownCards = (deck, numToPop) => {\r\n\t// make shallow copy of deck to not alter original deck attributes\r\n\tconst mutableDeckCopy = [...deck];\r\n\tlet chosenCards;\r\n\t// get last card \r\n\tif (numToPop === 1) {\r\n\t\tchosenCards = [mutableDeckCopy.pop()];\r\n\t} else {\r\n\t\t// get chosen cards from mutable deck copy one by one\r\n\t\tchosenCards = [];\r\n\t\tfor (let i = 0; i < numToPop; i++) {\r\n\t\t\tchosenCards.push(mutableDeckCopy.pop());\r\n\t\t}\r\n\t}\r\n\treturn { mutableDeckCopy, chosenCards }\r\n}\r\n\r\n/*\r\n  Find best hand amongst players still in a hand\r\n */\r\nconst findBestHand = (hand, bestRank, flushedSuit, flushCards, concurrentCardValues, concurrentCardValuesLow, isLowStraight, isLowStraightFlush, concurrentSFCardValues, concurrentSFCardValuesLow, frequencyHistogramMetaData) => {\r\n\t// check if hand matches any value from best to worst (Royal Flush to High Card)\r\n\tswitch (bestRank) {\r\n\t\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\t\tcase ('Royal Flush'): {\r\n\t\t\treturn flushCards.slice(0, 5)\r\n\t\t}\r\n\t\t// check if hand is five cards in sequence (all of same suit)\r\n\t\tcase ('Straight Flush'): {\r\n\t\t\tif (isLowStraightFlush && concurrentSFCardValues.length < 5) {\r\n\t\t\t\tconcurrentSFCardValuesLow[0] = 13\r\n\t\t\t\treturn concurrentSFCardValuesLow.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []).reverse();\r\n\t\t\t} else {\r\n\t\t\t\treturn concurrentSFCardValues.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(flushCards[flushCards.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is four cards all of the same denomination\r\n\t\tcase ('Four Of A Kind'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tconst indexOfQuad = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.quads[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfQuad])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfQuad)\r\n\t\t\t}\r\n\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 1))\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\tcase ('Full House'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tif (frequencyHistogramMetaData.tripples.length > 1) {\r\n\t\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[1].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t\t}\r\n\t\t\t\treturn bestHand\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t\t}\r\n\t\t\t\treturn bestHand\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is five cards all of the same suit\r\n\t\tcase ('Flush'): {\r\n\t\t\treturn flushCards.slice(0, 5)\r\n\t\t}\r\n\t\t// check if hand is five cards of any suit in sequence\r\n\t\tcase ('Straight'): {\r\n\t\t\tif (isLowStraight && concurrentCardValues.length < 5) {\r\n\t\t\t\tconcurrentCardValuesLow[0] = 13\r\n\t\t\t\treturn concurrentCardValuesLow.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(hand[hand.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []).reverse();\r\n\t\t\t} else {\r\n\t\t\t\treturn concurrentCardValues.reduce((acc, cur, index) => {\r\n\t\t\t\t\tif (index < 5) {\r\n\t\t\t\t\t\tacc.push(hand[hand.findIndex(match => match.value === cur)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn acc;\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tcase ('Three Of A Kind'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\r\n\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\tconst indexOfTripple = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.tripples[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfTripple])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfTripple)\r\n\t\t\t}\r\n\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 2))\r\n\t\t}\r\n\t\t// check if hand is two sets of two cards of the same denomination and any fifth card\r\n\t\tcase ('Two Pair'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(match => match.cardFace === frequencyHistogramMetaData.pairs[1].face);\r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((match, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 1))\r\n\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tcase ('Pair'): {\r\n\t\t\tconst bestHand = [];\r\n\t\t\tlet mutableHand = cloneDeep(hand);\r\n\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\tconst indexOfPair = mutableHand.findIndex(card => card.cardFace === frequencyHistogramMetaData.pairs[0].face);\r\n\t\t\t\t// CONSIDER : \r\n\t\t\t\tbestHand.push(mutableHand[indexOfPair])\r\n\t\t\t\tmutableHand = mutableHand.filter((card, index) => index !== indexOfPair)\r\n\t\t\t}\r\n\t\t\treturn bestHand.concat(mutableHand.slice(0, 3))\r\n\r\n\r\n\t\t}\r\n\t\t// check if hand is all five cards are unmatched\r\n\t\tcase ('No Pair'): {\r\n\t\t\treturn hand.slice(0, 5)\r\n\t\t}\r\n\t\tdefault: throw Error('Recieved unfamiliar rank argument in findBestHand()');\r\n\t}\r\n}\r\n\r\n/*\r\nGenerate set of five cards that add value to hand\r\n*/\r\nconst generateValueSet = (hand) => {\r\n\treturn Array.from(new Set(hand.map(cardInfo => cardInfo.value)))\r\n}\r\n\r\n/*\r\n  Determine ranking order of players' hands\r\n */\r\nconst determinePlayerHandsHierarchy = (sortedComparator, handRank) => {\r\n\tlet winnerHierarchy = [];\r\n\tlet loserHierarchy = [];\r\n\tconst processComparator = (comparator, round = 0) => {\r\n\t\tif (comparator[0].length === 1) {\r\n\t\t\tconst { name, bestHand } = comparator[0][0]\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([{ name, bestHand, handRank }])\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet filterableComparator = sortedComparator.map(el => el);\r\n\t\tconst frame = comparator[round];\r\n\t\tconst { winningFrame, losingFrame } = handleSnapshotFrame(frame);\r\n\t\t// find order of players who did not win hand\r\n\t\tif (losingFrame.length > 0) {\r\n\t\t\tconst lowerTierComparator = filterableComparator.map(frame => {\r\n\t\t\t\treturn frame.filter(snapshot => {\r\n\t\t\t\t\treturn losingFrame.some(snapshotToMatchName => {\r\n\t\t\t\t\t\treturn snapshotToMatchName.name === snapshot.name;\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\t// Push the filtered comparator to the start of the losers queue. \r\n\t\t\tloserHierarchy = [lowerTierComparator].concat(loserHierarchy);\r\n\t\t}\r\n\t\t// if only one winner they are best hand\r\n\t\tif (winningFrame.length === 1) {\r\n\t\t\tconst { name, bestHand } = winningFrame[0];\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([{\r\n\t\t\t\tname,\r\n\t\t\t\tbestHand,\r\n\t\t\t\thandRank\r\n\t\t\t}])\r\n\t\t\t// find order of players who won hand if more than one\r\n\t\t} else if (round === (sortedComparator.length - 1)) {\r\n\t\t\tconst filteredWinnerSnapshots = winningFrame.map(snapshot => ({\r\n\t\t\t\tname: snapshot.name,\r\n\t\t\t\tbestHand: snapshot.bestHand,\r\n\t\t\t\thandRank\r\n\t\t\t}))\r\n\t\t\twinnerHierarchy = winnerHierarchy.concat([filteredWinnerSnapshots]);\r\n\t\t} else {\r\n\t\t\tconst higherTierComparator = filterableComparator.map(frame => {\r\n\t\t\t\treturn frame.filter(snapshot => {\r\n\t\t\t\t\treturn winningFrame.some(snapshotToMatchName => {\r\n\t\t\t\t\t\treturn snapshotToMatchName.name === snapshot.name;\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tprocessComparator(higherTierComparator, (round + 1));\r\n\t\t}\r\n\t}\r\n\r\n\tconst processLowTierComparators = (loserHierarchyFrame) => {\r\n\t\tif (loserHierarchy.length > 0) {\r\n\t\t\tconst loserComparatorToProcess = loserHierarchyFrame[0];\r\n\t\t\tloserHierarchy = loserHierarchyFrame.slice(1);\r\n\t\t\tprocessComparator(loserComparatorToProcess);\r\n\t\t\tprocessLowTierComparators(loserHierarchy);\r\n\t\t}\r\n\t}\r\n\tprocessComparator(sortedComparator);\r\n\tprocessLowTierComparators(loserHierarchy);\r\n\treturn winnerHierarchy;\r\n}\r\n\r\n/*\r\n  Build ranking of hands of each player still in hand\r\n */\r\nconst buildPlayerRankings = (state) => {\r\n\r\n\t// only consider players still active in hand\r\n\tconst activePlayers = state.players.filter(player => !player.folded);\r\n\tlet hierarchy = [];\r\n\t// map of possible hand rankings\r\n\tconst rankMap = new Map([\r\n\t\t['Royal Flush', []],\r\n\t\t['Straight Flush', []],\r\n\t\t['Four Of A Kind', []],\r\n\t\t['Full House', []],\r\n\t\t['Flush', []],\r\n\t\t['Straight', []],\r\n\t\t['Three Of A Kind', []],\r\n\t\t['Two Pair', []],\r\n\t\t['Pair', []],\r\n\t\t['No Pair', []]\r\n\t]);\r\n\r\n\t// for each player find rank and add to ranking map\r\n\tactivePlayers.forEach((player, playerIndex) => {\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tshowDownHand: { bestHandRank, bestHand }\r\n\t\t} = player;\r\n\t\trankMap.get(bestHandRank).push({\r\n\t\t\tname,\r\n\t\t\tbestHand,\r\n\t\t\tplayerIndex\r\n\t\t})\r\n\t})\r\n\r\n\tfor (const [handRank, playersWhoHoldThisRank] of rankMap) {\r\n\t\tif (playersWhoHoldThisRank.length > 0) {\r\n\t\t\t// only one player can have Royal Flush so they would win regardless of the rest\r\n\t\t\tif (handRank === 'Royal Flush') {\r\n\t\t\t\tconst formattedPlayersWhoHoldThisRank = playersWhoHoldThisRank.map(player => ({\r\n\t\t\t\t\tname: player.name,\r\n\t\t\t\t\tbestHand: player.bestHand,\r\n\t\t\t\t\thandRank\r\n\t\t\t\t}))\r\n\t\t\t\thierarchy = hierarchy.concat(formattedPlayersWhoHoldThisRank);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// if only one player has a ranking that player is the best for that ranking\r\n\t\t\tif (playersWhoHoldThisRank.length === 1) {\r\n\t\t\t\tconst { name, bestHand } = playersWhoHoldThisRank[0];\r\n\t\t\t\thierarchy = hierarchy.concat([{\r\n\t\t\t\t\tname,\r\n\t\t\t\t\tbestHand,\r\n\t\t\t\t\thandRank\r\n\t\t\t\t}]);\r\n\t\t\t\t// if more than one player has same ranking must find which one has higher value\r\n\t\t\t} else if (playersWhoHoldThisRank.length > 1) {\r\n\t\t\t\tconst sortedComparator = createRankingsComparator(handRank, playersWhoHoldThisRank)\r\n\t\t\t\t\t.map((snapshot) => {\r\n\t\t\t\t\t\treturn snapshot.sort((a, b) => b.card.value - a.card.value)\r\n\t\t\t\t\t});\r\n\t\t\t\tconst winnerHierarchy = determinePlayerHandsHierarchy(sortedComparator, handRank);\r\n\t\t\t\thierarchy = hierarchy.concat(winnerHierarchy);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn hierarchy;\r\n}\r\n\r\n/*\r\n  Rank hands of players still active in hand\r\n */\r\nconst rankPlayersHands = (state, contestants) => {\r\n\r\n\t// map of possible hand rankings\r\n\tconst rankMap = new Map([\r\n\t\t['Royal Flush', []],\r\n\t\t['Straight Flush', []],\r\n\t\t['Four Of A Kind', []],\r\n\t\t['Full House', []],\r\n\t\t['Flush', []],\r\n\t\t['Straight', []],\r\n\t\t['Three Of A Kind', []],\r\n\t\t['Two Pair', []],\r\n\t\t['Pair', []],\r\n\t\t['No Pair', []]\r\n\t]);\r\n\r\n\tfor (let contestant of contestants) {\r\n\t\tconst playerIndex = state.players.findIndex(player => player.name === contestant);\r\n\t\tconst player = state.players[playerIndex];\r\n\t\t// if player is active in hand\r\n\t\tif (!player.folded) {\r\n\t\t\t// rank player hand\r\n\t\t\trankMap.get(player.showDownHand.bestHandRank).push({\r\n\t\t\t\tname: player.name,\r\n\t\t\t\tplayerIndex,\r\n\t\t\t\tbestHand: player.showDownHand.bestHand,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn rankMap;\r\n}\r\n\r\n/*\r\n  Handle and get snapshot with winners and losers of hand\r\n */\r\nconst handleSnapshotFrame = (frame) => {\r\n\tconst highValue = frame[0].card.value;\r\n\tconst winningFrame = frame.filter(snapshot => snapshot.card.value === highValue);\r\n\tconst losingFrame = frame.filter(snapshot => snapshot.card.value < highValue);\r\n\treturn { winningFrame, losingFrame }\r\n}\r\n\r\n/*\r\nGet cards dealt to a player\r\n*/\r\nconst getCards = (deck, numToGet) => {\r\n\t// make shallow copy of deck to not alter original deck attributes\r\n\tconst mutableDeckCopy = [...deck];\r\n\tlet chosenCards;\r\n\tif (numToGet === 1) {\r\n\t\t// get last card \r\n\t\tchosenCards = mutableDeckCopy.pop();\r\n\t} else {\r\n\t\t// get chosen cards from mutable deck copy one by one\r\n\t\tchosenCards = [];\r\n\t\tfor (let i = 0; i < numToGet; i++) {\r\n\t\t\tchosenCards.push(mutableDeckCopy.pop());\r\n\t\t}\r\n\t}\r\n\treturn { mutableDeckCopy, chosenCards }\r\n}\r\n\r\n/*\r\n  Assign winnings to hand winners (handles pot splits too)\r\n */\r\nconst assignWinnings = (state, rankMap, prize) => {\r\n\tlet winnerFound = false;\r\n\r\n\t// find hand winners\r\n\trankMap.forEach((contestants, rank, map) => {\r\n\t\tif (!winnerFound) {\r\n\t\t\t// if only one player active in hand they win\r\n\t\t\tif (contestants.length === 1) {\r\n\t\t\t\twinnerFound = true\r\n\t\t\t\tconsole.log(\"Winner, \", contestants[0].name, \" , beating out the competition with a \", rank)\r\n\t\t\t\tstate = payWinnings(state, contestants, prize, rank)\r\n\t\t\t\t// if more than one player active in hand find winner\r\n\t\t\t} else if (contestants.length > 1) {\r\n\t\t\t\tconsole.log(contestants)\r\n\t\t\t\twinnerFound = true\r\n\t\t\t\t// get active players hand rankings\r\n\t\t\t\tconst winners = findHandWinner(createRankingsComparator(rank, contestants), rank)\r\n\t\t\t\t// if only one player wins they get all the pot\r\n\t\t\t\tif (winners.length === 1) {\r\n\t\t\t\t\tconsole.log(\"Winner, \", winners[0].name, \" , beating out the competition with a \", rank)\r\n\t\t\t\t\tstate = payWinnings(state, winners, prize, rank)\r\n\t\t\t\t\t// if multilple players win the pot is split amongst them\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(\"We have a tie! Split the pot amongst \", winners, \" Who will take the pot with their \", rank)\r\n\t\t\t\t\tstate = payWinnings(state, winners, prize, rank)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Assign side pots when there are multiple winners for the same hand\r\n */\r\nconst assignSidePots = (state) => {\r\n\t// find winners of hand\r\n\tstate.playerHierarchy = buildPlayerRankings(state);\r\n\tconsole.log(\"Ultimate Player Hierarchy Determined:\")\r\n\tconsole.log(state.playerHierarchy);\r\n\r\n\t// assign each side pot to the corresponding winner\r\n\tfor (let sidePot of state.sidePots) {\r\n\t\tconst rankMap = rankPlayersHands(state, sidePot.contestants);\r\n\t\tstate = assignWinnings(state, rankMap, sidePot.potValue)\r\n\t}\r\n\r\n\tstate.players = state.players.map(player => ({\r\n\t\t...player,\r\n\t\troundEndChips: player.chips\r\n\t}));\r\n\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Pay winnings to hand winners\r\n */\r\nconst payWinnings = (state, winners, prize, rank) => {\r\n\t// if only one winner they win all the pot\r\n\tif (winners.length === 1) {\r\n\t\tstate.showDownMessages = state.showDownMessages.concat([{\r\n\t\t\tusers: [winners[0].name],\r\n\t\t\tprize,\r\n\t\t\trank\r\n\t\t}]);\r\n\t\tconsole.log(\"Transferring \", prize, \" chips to \", winners[0].name)\r\n\t\tstate.players[winners[0].playerIndex].chips += prize\r\n\t\tstate.pot -= prize\r\n\t\t// if more than one winner split pot accordingly between them\r\n\t} else if (winners.length > 1) {\r\n\t\tconst overflow = prize % winners.length;\r\n\t\tconst splitPot = Math.floor(prize / winners.length)\r\n\t\tconsole.log(\"Mediating Tie. Total Prize \", prize, \" split into \", winners.length, \" portions with an overflow of \", overflow)\r\n\t\tstate.showDownMessages = state.showDownMessages.concat([{\r\n\t\t\tusers: winners.map(winner => winner.name),\r\n\t\t\tprize: splitPot,\r\n\t\t\trank\r\n\t\t}])\r\n\t\twinners.forEach(winner => {\r\n\t\t\tstate.players[winner.playerIndex].chips += splitPot\r\n\t\t\tstate.pot -= splitPot\r\n\t\t})\r\n\t}\r\n\treturn state\r\n}\r\n\r\n/*\r\n  Create hand rankings comparator to compare hand rankings\r\n */\r\nconst createRankingsComparator = (rank, playerData) => {\r\n\tlet comparator;\r\n\tswitch (rank) {\r\n\t\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\t\tcase ('Royal Flush'): {\r\n\t\t\tcomparator = Array.from({ length: 1 });\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator.push({\r\n\t\t\t\t\t// there can only be one royal flush which will be the winner regardless of other hand rankings\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is four cards all of the same denomination\r\n\t\tcase ('Four Of A Kind'): {\r\n\t\t\tcomparator = Array.from({ length: 2 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// four cards all of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// last card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\tcase ('Full House'): {\r\n\t\t\tcomparator = Array.from({ length: 2 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// three cards of one denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// two cards of another denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of one denomination and two cards of another denomination\r\n\t\t// or if all five cards are unmatched\r\n\t\tcase ('Flush'):\r\n\t\tcase ('No Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 5 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tfor (let i = 0; i < 5; i++) {\r\n\t\t\t\t\tcomparator[i].push({\r\n\t\t\t\t\t\t// check all 5 cards of a flush or no-pair\r\n\t\t\t\t\t\tcard: playerData[index].bestHand[i],\r\n\t\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tcase ('Three Of A Kind'): {\r\n\t\t\tcomparator = Array.from({ length: 3 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// three cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// fourth card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fifth card is unmatched\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is five cards of any suit in sequence\r\n\t\t// or if hand is five cards in sequence (all of same suit)\r\n\t\tcase ('Straight'):\r\n\t\tcase ('Straight Flush'): {\r\n\t\t\tcomparator = Array.from({ length: 1 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// check highest card of a straight as it will determine the straight value\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is two sets of two cards of the same denomination and any fifth card\r\n\t\tcase ('Two Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 3 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// another two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[2],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fifth unmatched card\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tcase ('Pair'): {\r\n\t\t\tcomparator = Array.from({ length: 4 }, () => Array.from({ length: 0 }))\r\n\t\t\tplayerData.forEach((playerShowdownData, index) => {\r\n\t\t\t\tcomparator[0].push({\r\n\t\t\t\t\t// two cards of the same denomination\r\n\t\t\t\t\tcard: playerData[index].bestHand[0],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[1].push({\r\n\t\t\t\t\t// third unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[2],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[2].push({\r\n\t\t\t\t\t// fourth unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[3],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t\tcomparator[3].push({\r\n\t\t\t\t\t// fifth unmtached card\r\n\t\t\t\t\tcard: playerData[index].bestHand[4],\r\n\t\t\t\t\tname: playerData[index].name,\r\n\t\t\t\t\tplayerIndex: playerData[index].playerIndex,\r\n\t\t\t\t\tbestHand: playerData[index].bestHand\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tdefault: throw Error('Recieved unfamiliar rank argument in createRankingsComparator()');\r\n\t}\r\n\treturn comparator\r\n}\r\n\r\n/*\r\n  Find current hand winner\r\n */\r\nconst findHandWinner = (comparator, rank) => {\r\n\tlet winners;\r\n\tif (rank === 'Royal Flush') return comparator\r\n\tfor (let i = 0; i < comparator.length; i++) {\r\n\t\tlet highValue = 0;\r\n\t\tlet losers = [];\r\n\t\t// sort player rankings comparator \r\n\t\twinners = comparator[i].sort((a, b) => b.card.value - a.card.value).reduce((acc, cur, index) => {\r\n\t\t\t// add player with higher ranking hands first\r\n\t\t\tif (cur.card.value > highValue) {\r\n\r\n\t\t\t\thighValue = cur.card.value;\r\n\t\t\t\tacc.push({\r\n\t\t\t\t\tname: cur.name,\r\n\t\t\t\t\tplayerIndex: cur.playerIndex,\r\n\t\t\t\t});\r\n\t\t\t\treturn acc;\r\n\t\t\t} else if (cur.card.value === highValue) {\r\n\t\t\t\tacc.push({\r\n\t\t\t\t\tname: cur.name,\r\n\t\t\t\t\tplayerIndex: cur.playerIndex,\r\n\t\t\t\t});\r\n\t\t\t\treturn acc;\r\n\t\t\t\t// then add non active players (back of list)\r\n\t\t\t} else if (cur.card.value < highValue) {\r\n\t\t\t\tlosers.push(cur.name);\r\n\t\t\t\treturn acc;\r\n\t\t\t}\r\n\t\t}, [])\r\n\r\n\t\tif (winners.length === 1 || i === comparator.length) {\r\n\t\t\treturn winners\r\n\t\t} else {\r\n\t\t\tif (losers.length >= 1) {\r\n\t\t\t\tlosers.forEach((nameToExtract) => {\r\n\t\t\t\t\tcomparator = comparator.map(snapshot => snapshot.filter((el) => el.name !== nameToExtract));\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn winners\r\n\r\n}\r\n\r\n/*\r\n  Check if hand is a Flush\r\n */\r\nconst checkIfFlush = (suitHistogram) => {\r\n\tlet isFlush;\r\n\tlet flushedSuit;\r\n\t// check if all five cards have the same suit\r\n\tfor (let suit in suitHistogram) {\r\n\t\tif (suitHistogram[suit] >= 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisFlush: true,\r\n\t\t\t\tflushedSuit: suit,\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\tisFlush: false,\r\n\t\tflushedSuit: null,\r\n\t}\r\n}\r\n/*\r\n  Check if hand is straight with Ace, two, three, four, five\r\n */\r\nconst checkIfLowerStraight = (valueSetCopy) => {\r\n\tlet numConcurrentCards = 0;\r\n\tlet concurrentCardValuesLow = [];\r\n\t// Convert Ace which has highest value of 13 to lowest value 0 from which straight would start\r\n\tvalueSetCopy[0] = 0;\r\n\t// sort card values\r\n\tconst sortedValueSetCopy = valueSetCopy.map(el => el).sort((a, b) => a - b);\r\n\t// check if Ace, two, three, four, five are found\r\n\tfor (let i = 1; i < 5; i++) {\r\n\t\tif (numConcurrentCards >= 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisLowStraight: true,\r\n\t\t\t\tconcurrentCardValuesLow,\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((sortedValueSetCopy[i] - sortedValueSetCopy[i - 1]) === 1) {\r\n\t\t\tif (numConcurrentCards === 0) {\r\n\t\t\t\tnumConcurrentCards = 2;\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i - 1]);\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i]);\r\n\t\t\t} else {\r\n\t\t\t\tnumConcurrentCards++;\r\n\t\t\t\tconcurrentCardValuesLow.push(sortedValueSetCopy[i]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnumConcurrentCards = 0;\r\n\t\t\tconcurrentCardValuesLow = [];\r\n\t\t}\r\n\t}\r\n\tif (numConcurrentCards >= 5) {\r\n\t\treturn {\r\n\t\t\tisLowStraight: true,\r\n\t\t\tconcurrentCardValuesLow,\r\n\t\t}\r\n\t} else {\r\n\t\treturn {\r\n\t\t\tisLowStraight: false,\r\n\t\t\tconcurrentCardValuesLow,\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n  Check if hand is a Royal Flush\r\n */\r\nconst checkIfRoyalFlush = (flushMatchCards) => {\r\n\t// check if hand is Ten, Jack, Queen, King and Ace (all of same suit)\r\n\tif ((flushMatchCards[0].value === 13) &&\r\n\t\t(flushMatchCards[1].value === 12) &&\r\n\t\t(flushMatchCards[2].value === 11) &&\r\n\t\t(flushMatchCards[3].value === 10) &&\r\n\t\t(flushMatchCards[4].value === 10)) {\r\n\t\treturn true\r\n\t} else { return false }\r\n}\r\n\r\n/*\r\n  Check if hand is a Straight\r\n */\r\nconst checkIfStraight = (valueSet) => {\r\n\t// if less than five cards are valuable to the hand it is not a straight\r\n\tif (valueSet.length < 5) return false\r\n\tlet numConcurrentCards = 0;\r\n\tlet concurrentCardValues = [];\r\n\t// check if hand is five cards of any suit in sequence\r\n\tfor (let i = 1; i < valueSet.length; i++) {\r\n\t\tif (numConcurrentCards === 5) {\r\n\t\t\treturn {\r\n\t\t\t\tisStraight: true,\r\n\t\t\t\tconcurrentCardValues\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((valueSet[i] - valueSet[i - 1]) === -1) {\r\n\t\t\tif (numConcurrentCards === 0) {\r\n\t\t\t\tnumConcurrentCards = 2;\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i - 1]);\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i]);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tnumConcurrentCards++;\r\n\t\t\t\tconcurrentCardValues.push(valueSet[i]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnumConcurrentCards = 0;\r\n\t\t\tconcurrentCardValues = [];\r\n\t\t}\r\n\t}\r\n\tif (numConcurrentCards >= 5) {\r\n\t\treturn {\r\n\t\t\tisStraight: true,\r\n\t\t\tconcurrentCardValues\r\n\t\t}\r\n\t} else {\r\n\t\t// check if is straight with Ace, two, three, four, five\r\n\t\tif (valueSet[0] === 13) {\r\n\t\t\tlet { isLowStraight, concurrentCardValuesLow } = checkIfLowerStraight(cloneDeep(valueSet));\r\n\r\n\t\t\tif (isLowStraight) return {\r\n\t\t\t\tisStraight: true,\r\n\t\t\t\tisLowStraight,\r\n\t\t\t\tconcurrentCardValues,\r\n\t\t\t\tconcurrentCardValuesLow,\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tisStraight: false,\r\n\t\t\tisLowStraight: false,\r\n\t\t\tconcurrentCardValues,\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n  Check if hand is a Straight Flush\r\n */\r\nconst checkIfStraightFlush = (flushMatchCards) => {\r\n\t// check if hand is five cards in sequence (all of same suit)\r\n\tconst valueSet = generateValueSet(flushMatchCards);\r\n\tconst { isStraight, isLowStraight, concurrentCardValues, concurrentCardValuesLow } = checkIfStraight(valueSet);\r\n\treturn {\r\n\t\tisStraightFlush: isStraight,\r\n\t\tisLowStraightFlush: isLowStraight,\r\n\t\tconcurrentSFCardValues: concurrentCardValues,\r\n\t\tconcurrentSFCardValuesLow: concurrentCardValuesLow,\r\n\t}\r\n}\r\n\r\n/*\r\n  Check how many hand rankings have occured and with what frequence \r\n  and order\r\n */\r\nconst checkFrequencyHistogram = (hand, frequencyHistogram) => {\r\n\r\n\t// set hand rankings to not seen \r\n\tlet isFourOfAKind = false;\r\n\tlet isFullHouse = false\r\n\tlet isThreeOfAKind = false;\r\n\tlet isTwoPair = false;\r\n\tlet isPair = false;\r\n\tlet numTripples = 0;\r\n\tlet numPairs = 0;\r\n\tlet frequencyHistogramMetaData = {\r\n\t\tpairs: [],\r\n\t\ttripples: [],\r\n\t\tquads: [],\r\n\t}\r\n\t// check if hand is four cards all of the same denomination\r\n\tfor (let cardFace in frequencyHistogram) {\r\n\t\tif (frequencyHistogram[cardFace] === 4) {\r\n\t\t\tisFourOfAKind = true\r\n\t\t\tfrequencyHistogramMetaData.quads.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t\t// check if hand is three cards of the same denomination and two unmatched cards\r\n\t\tif (frequencyHistogram[cardFace] === 3) {\r\n\t\t\tisThreeOfAKind = true\r\n\t\t\tnumTripples++\r\n\t\t\tfrequencyHistogramMetaData.tripples.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t\t// check if hand is two cards of the same denomination and three unmatched cards\r\n\t\tif (frequencyHistogram[cardFace] === 2) {\r\n\t\t\tisPair = true\r\n\t\t\tnumPairs++\r\n\t\t\tfrequencyHistogramMetaData.pairs.push({\r\n\t\t\t\tface: cardFace,\r\n\t\t\t\tvalue: VALUE_MAP[cardFace]\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t// sort histogram from best hand to worst hand\r\n\tfrequencyHistogramMetaData.pairs = frequencyHistogramMetaData.pairs.map(el => el).sort((a, b) => b.value - a.value)\r\n\tfrequencyHistogramMetaData.tripples = frequencyHistogramMetaData.tripples.map(el => el).sort((a, b) => b.value - a.value)\r\n\tfrequencyHistogramMetaData.quads = frequencyHistogramMetaData.quads.map(el => el).sort((a, b) => b.value - a.value)\r\n\r\n\t// check if hand is three cards of one denomination and two cards of another denomination (full house)\r\n\tif ((numTripples >= 2) || (numPairs >= 1 && numTripples >= 1)) {\r\n\t\tisFullHouse = true\r\n\t}\r\n\t// check if hand is two sets of two cards of the same denomination and any fifth card (Two Pairs)\r\n\tif (numPairs >= 2) {\r\n\t\tisTwoPair = true\r\n\t}\r\n\r\n\treturn {\r\n\t\tisFourOfAKind,\r\n\t\tisFullHouse,\r\n\t\tisThreeOfAKind,\r\n\t\tisTwoPair,\r\n\t\tisPair,\r\n\t\tfrequencyHistogramMetaData\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nexport { makeDeckOfCards, shuffleCards, dealPlayerCards, getCards, dealFlopCards, dealTurnCards, dealRiverCards, dealOtherCommunityCards, playerShowDown, checkIfFlush, checkIfRoyalFlush, checkIfStraightFlush, checkIfStraight, checkFrequencyHistogram, generateValueSet };\r\n\r\n"]},"metadata":{},"sourceType":"module"}