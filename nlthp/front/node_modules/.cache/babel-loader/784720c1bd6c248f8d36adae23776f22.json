{"ast":null,"code":"import _createForOfIteratorHelper from\"C:/Users/manny/fyp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{dealFlopCards,dealRiverCards,dealTurnCards,playerShowDown}from'./cardsService.js';import{chooseNextActivePlayer}from'./playersService.js';/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/var calculateBlindIndices=function calculateBlindIndices(dealerIndex,numPlayers){return{bigBlindIndex:(dealerIndex+2)%numPlayers,smallBlindIndex:(dealerIndex+1)%numPlayers};};var anteUpBlinds=function anteUpBlinds(players,blindIndices,minBet){var bigBlindIndex=blindIndices.bigBlindIndex,smallBlindIndex=blindIndices.smallBlindIndex;players[bigBlindIndex].bet=minBet;players[bigBlindIndex].chips=players[bigBlindIndex].chips-minBet;players[smallBlindIndex].bet=minBet/2;players[smallBlindIndex].chips=players[smallBlindIndex].chips-minBet/2;return players;};var calculateMinBet=function calculateMinBet(highBet,playerChipsStack,playerBet){var playerTotalChips=playerChipsStack+playerBet;if(playerTotalChips<highBet){return playerTotalChips;}else{return highBet;}};/* \r\nDetermines the integrity of all bets.\r\n*/var manageBet=function manageBet(state,bet,min,max){if(bet<min){state.betInputValue=min;return console.log(\"Invalid Bet\");}if(bet>max){state.betInputValue=max;return console.log(\"Invalid Bet\");}if(bet>state.highBet){// minbet and highbet may be condensed to a single property\nstate.highBet=bet;state.minBet=state.highBet;var _iterator=_createForOfIteratorHelper(state.players),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var player=_step.value;if(!player.folded||!player.chips===0){player.betReconciled=false;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}var activePlayer=state.players[state.activePlayerIndex];var subtractableChips=bet-activePlayer.bet;activePlayer.bet=bet;activePlayer.chips=activePlayer.chips-subtractableChips;if(activePlayer.chips===0){activePlayer.allIn=true;state.numPlayersAllIn++;}activePlayer.betReconciled=true;return chooseNextActivePlayer(state);};var managePlayerFold=function managePlayerFold(state){var activePlayer=state.players[state.activePlayerIndex];activePlayer.folded=true;activePlayer.betReconciled=true;state.numPlayersFolded++;state.numPlayersActive--;var nextState=chooseNextActivePlayer(state);return nextState;};var managePhaseShift=function managePhaseShift(state){switch(state.phase){case'betting1':{state.phase='flop';return dealFlopCards(remakePot(state));}case'betting2':{state.phase='turn';return dealTurnCards(remakePot(state));}case'betting3':{state.phase='river';return dealRiverCards(remakePot(state));}case'betting4':{state.phase='showdown';return playerShowDown(remakePot(state));}default:throw Error(\"managePhaseShift() called from non-betting phase\");}};/* \r\nCombine sidepots into a single pot to save resources.\r\n*/var remakePot=function remakePot(state){var _iterator2=_createForOfIteratorHelper(state.players),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var player=_step2.value;state.pot=state.pot+player.bet;player.sidePotStack=player.bet;player.betReconciled=false;}// condense pots as processing each one requires expensive card comparator functions\n}catch(err){_iterator2.e(err);}finally{_iterator2.f();}state=condensePots(calculatePots(state,state.players));var _iterator3=_createForOfIteratorHelper(state.players),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _player=_step3.value;_player.currentRoundChipsInvested+=_player.bet;_player.bet=0;// reset all player bets to 0 for the start of the next round\n}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}state.minBet=0;// reset markers which control min/max bet validation\nstate.highBet=0;state.betInputValue=0;return state;};/* \r\n Determine which players are included in the current pot.\r\n*/var calculatePots=function calculatePots(state,playerStacks){// remove players who did not bet from pot\nvar investedPlayers=playerStacks.filter(function(player){return player.sidePotStack>0;});if(investedPlayers.length===0){return state;}if(investedPlayers.length===1){// refund players who bet in excess of pot\nvar playerToRefund=state.players[state.players.findIndex(function(player){return player.name===investedPlayers[0].name;})];playerToRefund.chips=playerToRefund.chips+investedPlayers[0].sidePotStack;state.pot-=investedPlayers[0].sidePotStack;return state;}// sort players\nvar ascBetPlayers=investedPlayers.sort(function(a,b){return a.sidePotStack-b.sidePotStack;});var smallStackValue=ascBetPlayers[0].sidePotStack;var builtSidePot=ascBetPlayers.reduce(function(acc,cur){if(!cur.folded){acc.contestants.push(cur.name);}acc.potValue=acc.potValue+smallStackValue;cur.sidePotStack=cur.sidePotStack-smallStackValue;return acc;},{contestants:[],potValue:0});state.sidePots.push(builtSidePot);return calculatePots(state,ascBetPlayers);};/* \r\n Condenses mutiple pots into a single pot. \r\n*/var condensePots=function condensePots(state){if(state.sidePots.length>1){for(var i=0;i<state.sidePots.length;i++){var _loop=function _loop(n){if(arrayIdentical(state.sidePots[i].contestants,state.sidePots[n].contestants)){state.sidePots[i].potValue=state.sidePots[i].potValue+state.sidePots[n].potValue;state.sidePots=state.sidePots.filter(function(el,index){return index!==n;});}};for(var n=i+1;n<state.sidePots.length;n++){_loop(n);}}}return state;};var arrayIdentical=function arrayIdentical(arr1,arr2){if(arr1.length!==arr2.length){return false;}return arr1.map(function(el){return arr2.includes(el);}).filter(function(bool){return bool!==true;}).length!==0?false:true;};export{calculateBlindIndices,anteUpBlinds,calculateMinBet,manageBet,managePlayerFold,managePhaseShift,remakePot};","map":{"version":3,"sources":["C:/Users/manny/fyp/src/services/betService.js"],"names":["dealFlopCards","dealRiverCards","dealTurnCards","playerShowDown","chooseNextActivePlayer","calculateBlindIndices","dealerIndex","numPlayers","bigBlindIndex","smallBlindIndex","anteUpBlinds","players","blindIndices","minBet","bet","chips","calculateMinBet","highBet","playerChipsStack","playerBet","playerTotalChips","manageBet","state","min","max","betInputValue","console","log","player","folded","betReconciled","activePlayer","activePlayerIndex","subtractableChips","allIn","numPlayersAllIn","managePlayerFold","numPlayersFolded","numPlayersActive","nextState","managePhaseShift","phase","remakePot","Error","pot","sidePotStack","condensePots","calculatePots","currentRoundChipsInvested","playerStacks","investedPlayers","filter","length","playerToRefund","findIndex","name","ascBetPlayers","sort","a","b","smallStackValue","builtSidePot","reduce","acc","cur","contestants","push","potValue","sidePots","i","n","arrayIdentical","el","index","arr1","arr2","map","includes","bool"],"mappings":"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","sourcesContent":["import { dealFlopCards, dealRiverCards, dealTurnCards, playerShowDown } from './cardsService.js';\r\nimport { chooseNextActivePlayer } from './playersService.js';\r\n\r\n/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/\r\n\r\nconst calculateBlindIndices = (dealerIndex, numPlayers) => {\r\n\treturn ({\r\n\t\tbigBlindIndex: (dealerIndex + 2) % numPlayers,\r\n\t\tsmallBlindIndex: (dealerIndex + 1) % numPlayers,\r\n\t});\r\n}\r\n\r\nconst anteUpBlinds = (players, blindIndices, minBet) => {\r\n\tconst { bigBlindIndex, smallBlindIndex } = blindIndices;\r\n\tplayers[bigBlindIndex].bet = minBet;\r\n\tplayers[bigBlindIndex].chips = players[bigBlindIndex].chips - minBet;\r\n\tplayers[smallBlindIndex].bet = minBet / 2;\r\n\tplayers[smallBlindIndex].chips = players[smallBlindIndex].chips - (minBet / 2);\r\n\treturn players\r\n}\r\n\r\nconst calculateMinBet = (highBet, playerChipsStack, playerBet) => {\r\n\tconst playerTotalChips = playerChipsStack + playerBet\r\n\tif (playerTotalChips < highBet) {\r\n\t\treturn playerTotalChips;\r\n\t} else {\r\n\t\treturn highBet;\r\n\t}\r\n}\r\n\r\n/* \r\nDetermines the integrity of all bets.\r\n*/\r\nconst manageBet = (state, bet, min, max) => {\r\n\tif (bet < min) {\r\n\t\tstate.betInputValue = min;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\tif (bet > max) {\r\n\t\tstate.betInputValue = max;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\r\n\tif (bet > state.highBet) {\r\n\t\t// minbet and highbet may be condensed to a single property\r\n\t\tstate.highBet = bet;\r\n\t\tstate.minBet = state.highBet;\r\n\t\tfor (let player of state.players) {\r\n\t\t\tif (!player.folded || !player.chips === 0) {\r\n\t\t\t\tplayer.betReconciled = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tconst subtractableChips = bet - activePlayer.bet;\r\n\tactivePlayer.bet = bet;\r\n\r\n\tactivePlayer.chips = activePlayer.chips - subtractableChips;\r\n\tif (activePlayer.chips === 0) {\r\n\t\tactivePlayer.allIn = true;\r\n\t\tstate.numPlayersAllIn++\r\n\t}\r\n\tactivePlayer.betReconciled = true;\r\n\treturn chooseNextActivePlayer(state)\r\n}\r\n\r\nconst managePlayerFold = (state) => {\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tactivePlayer.folded = true;\r\n\tactivePlayer.betReconciled = true;\r\n\tstate.numPlayersFolded++\r\n\tstate.numPlayersActive--\r\n\r\n\tconst nextState = chooseNextActivePlayer(state)\r\n\treturn nextState\r\n}\r\n\r\nconst managePhaseShift = (state) => {\r\n\tswitch (state.phase) {\r\n\t\tcase ('betting1'): {\r\n\t\t\tstate.phase = 'flop';\r\n\t\t\treturn dealFlopCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('betting2'): {\r\n\t\t\tstate.phase = 'turn';\r\n\t\t\treturn dealTurnCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('betting3'): {\r\n\t\t\tstate.phase = 'river'\r\n\t\t\treturn dealRiverCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('betting4'): {\r\n\t\t\tstate.phase = 'showdown'\r\n\t\t\treturn playerShowDown(remakePot(state));\r\n\t\t}\r\n\t\tdefault: throw Error(\"managePhaseShift() called from non-betting phase\")\r\n\t}\r\n}\r\n\r\n/* \r\nCombine sidepots into a single pot to save resources.\r\n*/\r\nconst remakePot = (state) => {\r\n\tfor (let player of state.players) {\r\n\r\n\t\tstate.pot = state.pot + player.bet;\r\n\r\n\t\tplayer.sidePotStack = player.bet;\r\n\t\tplayer.betReconciled = false;\r\n\t}\r\n\r\n\t// condense pots as processing each one requires expensive card comparator functions\r\n\tstate = condensePots(calculatePots(state, state.players));\r\n\r\n\tfor (let player of state.players) {\r\n\t\tplayer.currentRoundChipsInvested += player.bet;\r\n\t\tplayer.bet = 0 // reset all player bets to 0 for the start of the next round\r\n\t}\r\n\r\n\tstate.minBet = 0; // reset markers which control min/max bet validation\r\n\tstate.highBet = 0;\r\n\tstate.betInputValue = 0;\r\n\treturn state\r\n}\r\n\r\n/* \r\n Determine which players are included in the current pot.\r\n*/\r\nconst calculatePots = (state, playerStacks) => {\r\n\t// remove players who did not bet from pot\r\n\tconst investedPlayers = playerStacks.filter(player => player.sidePotStack > 0)\r\n\tif (investedPlayers.length === 0) {\r\n\t\treturn state\r\n\t}\r\n\tif (investedPlayers.length === 1) {\r\n\t\t// refund players who bet in excess of pot\r\n\t\tconst playerToRefund = state.players[state.players.findIndex(player => player.name === investedPlayers[0].name)];\r\n\t\tplayerToRefund.chips = playerToRefund.chips + investedPlayers[0].sidePotStack;\r\n\t\tstate.pot -= investedPlayers[0].sidePotStack\r\n\t\treturn state\r\n\t}\r\n\t// sort players\r\n\tconst ascBetPlayers = investedPlayers.sort((a, b) => a.sidePotStack - b.sidePotStack);\r\n\tconst smallStackValue = ascBetPlayers[0].sidePotStack;\r\n\r\n\tconst builtSidePot = ascBetPlayers.reduce((acc, cur) => {\r\n\t\tif (!cur.folded) {\r\n\t\t\tacc.contestants.push(cur.name);\r\n\t\t}\r\n\t\tacc.potValue = acc.potValue + smallStackValue;\r\n\t\tcur.sidePotStack = cur.sidePotStack - smallStackValue;\r\n\t\treturn acc\r\n\t}, {\r\n\t\tcontestants: [],\r\n\t\tpotValue: 0,\r\n\t});\r\n\tstate.sidePots.push(builtSidePot);\r\n\treturn calculatePots(state, ascBetPlayers)\r\n\r\n}\r\n\r\n/* \r\n Condenses mutiple pots into a single pot. \r\n*/\r\nconst condensePots = (state) => {\r\n\tif (state.sidePots.length > 1) {\r\n\t\tfor (let i = 0; i < state.sidePots.length; i++) {\r\n\t\t\tfor (let n = i + 1; n < state.sidePots.length; n++) {\r\n\t\t\t\tif (arrayIdentical(state.sidePots[i].contestants, state.sidePots[n].contestants)) {\r\n\t\t\t\t\tstate.sidePots[i].potValue = state.sidePots[i].potValue + state.sidePots[n].potValue;\r\n\t\t\t\t\tstate.sidePots = state.sidePots.filter((el, index) => index !== n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn state\r\n}\r\n\r\nconst arrayIdentical = (arr1, arr2) => {\r\n\r\n\tif (arr1.length !== arr2.length) {\r\n\t\treturn false\r\n\t}\r\n\treturn arr1.map(el => arr2.includes(el)).filter(bool => bool !== true).length !== 0 ? false : true;\r\n}\r\nexport {\r\n\tcalculateBlindIndices,\r\n\tanteUpBlinds,\r\n\tcalculateMinBet,\r\n\tmanageBet,\r\n\tmanagePlayerFold,\r\n\tmanagePhaseShift,\r\n\tremakePot\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}