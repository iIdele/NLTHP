{"ast":null,"code":"import uuid from 'uuid/v1';\nimport { anteUpBlinds, calculateBlindIndices, managePhaseShift, remakePot } from './betService.js';\nimport { dealOtherCommunityCards, dealPlayerCards, makeDeckOfCards, playerShowDown, shuffleCards } from './cardsService.js';\n/** \r\n* The playerService provides services to handle\r\n* player information and the passing of information\r\n* to players.\r\n*/\n\n/* \r\nIntialise user and agents data\r\n*/\n\nconst axios = require('axios');\n\nconst makeTable = async (playerName = \"User\") => {\n  // a list containing both the user and the agents data\n  const users = [{\n    id: uuid(),\n    name: playerName,\n    avatar: '/assets/playerIcons/greenUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: false\n  }, {\n    id: uuid(),\n    name: 'Agent 1',\n    avatar: '/assets/playerIcons/blueUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: true\n  }, {\n    id: uuid(),\n    name: 'Agent 2',\n    avatar: '/assets/playerIcons/redUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: true\n  }, {\n    id: uuid(),\n    name: 'Agent 3',\n    avatar: '/assets/playerIcons/purpleUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: true\n  }, {\n    id: uuid(),\n    name: 'Agent 4',\n    avatar: '/assets/playerIcons/yellowUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: true\n  }, {\n    id: uuid(),\n    name: 'Agent 5',\n    avatar: '/assets/playerIcons/brownUser.svg',\n    cards: [],\n    showDownHand: {\n      hand: [],\n      descendingSortHand: []\n    },\n    chips: 20000,\n    roundStartChips: 20000,\n    roundEndChips: 20000,\n    currentRoundChipsInvested: 0,\n    bet: 0,\n    betReconciled: false,\n    folded: false,\n    allIn: false,\n    canRaise: true,\n    stackInvestment: 0,\n    agent: true\n  }];\n  return users;\n};\n/* \r\n Used to create agents of different difficulties\r\n */\n\n\nconst makePersonality = seed => {\n  switch (seed) {\n    // intermediate/advanced ai\n    case seed > 0.5:\n      return 'standard';\n    // beginner ai\n\n    case seed > 0.35:\n      return 'aggressive';\n\n    case seed > 0: // intermediate/advanced ai\n\n    default:\n      return 'conservative';\n  }\n};\n\nconst manageOverflowIndex = (currentIndex, incrementBy, arrayLength, direction) => {\n  switch (direction) {\n    case 'up':\n      {\n        return (currentIndex + incrementBy) % arrayLength;\n      }\n\n    case 'down':\n      {\n        return (currentIndex - incrementBy) % arrayLength + arrayLength;\n      }\n\n    default:\n      throw Error(\"Attempted to overfow index on unfamiliar direction\");\n  }\n};\n/* \r\n Determines which player starts the round\r\n */\n\n\nconst choosePhaseStartActivePlayer = (state, recursion = false) => {\n  if (!recursion) {\n    state.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up');\n  } else if (recursion) {\n    state.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\n  }\n\n  if (state.players[state.activePlayerIndex].folded) {\n    return choosePhaseStartActivePlayer(state, true);\n  }\n\n  if (state.players[state.activePlayerIndex].chips === 0) {\n    return choosePhaseStartActivePlayer(state, true);\n  }\n\n  return state;\n};\n/* \r\n Determines which players turn is next\r\n */\n\n\nconst chooseNextActivePlayer = state => {\n  state.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\n  const activePlayer = state.players[state.activePlayerIndex];\n  const allButOnePlayersAreAllIn = state.playersActive - state.playersAllIn === 1;\n\n  if (state.playersActive === 1) {\n    console.log(\"Only one player active, skipping to showdown.\");\n    return playerShowDown(remakePot(dealOtherCommunityCards(state)));\n  }\n\n  if (activePlayer.folded) {\n    console.log(\"Current player index is folded, going to next active player.\");\n    return chooseNextActivePlayer(state);\n  }\n\n  if (allButOnePlayersAreAllIn && !activePlayer.folded && activePlayer.betReconciled) {\n    return playerShowDown(remakePot(dealOtherCommunityCards(state)));\n  }\n\n  if (activePlayer.chips === 0) {\n    if (state.playersAllIn === state.playersActive) {\n      console.log(\"All players are all in.\");\n      return playerShowDown(remakePot(dealOtherCommunityCards(state)));\n    } else if (allButOnePlayersAreAllIn && activePlayer.allIn) {\n      return playerShowDown(remakePot(dealOtherCommunityCards(state)));\n    } else {\n      return chooseNextActivePlayer(state);\n    }\n  }\n\n  if (activePlayer.betReconciled) {\n    console.log(\"Player is reconciled with pot, round betting cycle complete, proceed to next round.\");\n    return managePhaseShift(state);\n  }\n\n  return state;\n};\n/* \r\n The dealer chip is assigned to the \r\n player acting as the dealer in \r\n a given round.\r\n */\n\n\nconst moveDealerChip = state => {\n  state.dealerIndex = manageOverflowIndex(state.dealerIndex, 1, state.players.length, 'up');\n  const nextDealer = state.players[state.dealerIndex];\n\n  if (nextDealer.chips === 0) {\n    return moveDealerChip(state);\n  }\n\n  return findBrokePlayers(state, nextDealer.name);\n};\n/* \r\n Finds and remove players with no funds remaining,\r\n shifts dealer if necessary and prepares state for \r\n next game phase.\r\n */\n\n\nconst findBrokePlayers = (state, dealerID) => {\n  state.players = state.players.filter(player => player.chips > 0);\n  const newDealerIndex = state.players.findIndex(player => player.name === dealerID);\n  state.dealerIndex = newDealerIndex;\n  state.activePlayerIndex = newDealerIndex;\n\n  if (state.players.length === 1) {\n    // winner determined\n    return state;\n  } else if (state.players.length === 2) {\n    state.blindIndex.small = newDealerIndex;\n    state.blindIndex.big = manageOverflowIndex(newDealerIndex, 1, state.players.length, 'up');\n    state.players = anteUpBlinds(state.players, {\n      bigBlindIndex: state.blindIndex.big,\n      smallBlindIndex: state.blindIndex.small\n    }, state.minBet).map(player => ({ ...player,\n      cards: [],\n      showDownHand: {\n        hand: [],\n        descendingSortHand: []\n      },\n      roundStartChips: player.chips + player.bet,\n      currentRoundChipsInvested: 0,\n      betReconciled: false,\n      folded: false,\n      allIn: false\n    }));\n    state.playersAllIn = 0;\n    state.playersFolded = 0;\n    state.playersActive = state.players.length;\n  } else {\n    const blindIndicies = calculateBlindIndices(newDealerIndex, state.players.length);\n    state.blindIndex = {\n      big: blindIndicies.bigBlindIndex,\n      small: blindIndicies.smallBlindIndex\n    };\n    state.players = anteUpBlinds(state.players, blindIndicies, state.minBet).map(player => ({ ...player,\n      cards: [],\n      showDownHand: {\n        hand: [],\n        descendingSortHand: []\n      },\n      roundStartChips: player.chips + player.bet,\n      currentRoundChipsInvested: 0,\n      betReconciled: false,\n      folded: false,\n      allIn: false\n    }));\n    state.playersAllIn = 0;\n    state.playersFolded = 0;\n    state.playersActive = state.players.length;\n  }\n\n  return dealPlayerCards(state);\n};\n/* \r\n Increments state to next game phase and \r\n shifts dealer.\r\n */\n\n\nconst startNextRound = state => {\n  state.communityCards = [];\n  state.sidePots = [];\n  state.playerHierarchy = [];\n  state.showDownMessages = [];\n  state.deck = shuffleCards(makeDeckOfCards());\n  state.highBet = 20;\n  state.betInputValue = 20;\n  state.minBet = 20; // can export out to initialState\n  // Unmount all cards so react can re-trigger animations\n\n  const {\n    players\n  } = state;\n  const clearPlayerCards = players.map(player => ({ ...player,\n    cards: player.cards.map(card => {})\n  }));\n  state.players = clearPlayerCards;\n  return moveDealerChip(state);\n};\n/* \r\n Check if the game has a winner.\r\n */\n\n\nconst checkWin = players => {\n  return players.filter(player => player.chips > 0).length === 1;\n};\n\nexport { makeTable, manageOverflowIndex, chooseNextActivePlayer, choosePhaseStartActivePlayer, startNextRound, checkWin };","map":{"version":3,"sources":["C:/Users/manny/2021-ca400-idelegi2-puzzuos2/src/ui/src/services/playersService.js"],"names":["uuid","anteUpBlinds","calculateBlindIndices","managePhaseShift","remakePot","dealOtherCommunityCards","dealPlayerCards","makeDeckOfCards","playerShowDown","shuffleCards","axios","require","makeTable","playerName","users","id","name","avatar","cards","showDownHand","hand","descendingSortHand","chips","roundStartChips","roundEndChips","currentRoundChipsInvested","bet","betReconciled","folded","allIn","canRaise","stackInvestment","agent","makePersonality","seed","manageOverflowIndex","currentIndex","incrementBy","arrayLength","direction","Error","choosePhaseStartActivePlayer","state","recursion","activePlayerIndex","blindIndex","big","players","length","chooseNextActivePlayer","activePlayer","allButOnePlayersAreAllIn","playersActive","playersAllIn","console","log","moveDealerChip","dealerIndex","nextDealer","findBrokePlayers","dealerID","filter","player","newDealerIndex","findIndex","small","bigBlindIndex","smallBlindIndex","minBet","map","playersFolded","blindIndicies","startNextRound","communityCards","sidePots","playerHierarchy","showDownMessages","deck","highBet","betInputValue","clearPlayerCards","card","checkWin"],"mappings":"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","sourcesContent":["import uuid from 'uuid/v1';\r\nimport { anteUpBlinds, calculateBlindIndices, managePhaseShift, remakePot } from './betService.js';\r\nimport { dealOtherCommunityCards, dealPlayerCards, makeDeckOfCards, playerShowDown, shuffleCards } from './cardsService.js';\r\n\r\n/** \r\n* The playerService provides services to handle\r\n* player information and the passing of information\r\n* to players.\r\n*/\r\n\r\n/* \r\nIntialise user and agents data\r\n*/\r\nconst axios = require('axios')\r\nconst makeTable = async (playerName = \"User\") => {\r\n\t// a list containing both the user and the agents data\r\n\tconst users = [{\r\n\t\tid: uuid(),\r\n\t\tname: playerName,\r\n\t\tavatar: '/assets/playerIcons/greenUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: false\r\n\t},\r\n\t{\r\n\t\tid: uuid(),\r\n\t\tname: 'Agent 1',\r\n\t\tavatar: '/assets/playerIcons/blueUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: true\r\n\t},\r\n\t{\r\n\t\tid: uuid(),\r\n\t\tname: 'Agent 2',\r\n\t\tavatar: '/assets/playerIcons/redUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: true\r\n\t},\r\n\t{\r\n\t\tid: uuid(),\r\n\t\tname: 'Agent 3',\r\n\t\tavatar: '/assets/playerIcons/purpleUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: true\r\n\t},\r\n\t{\r\n\t\tid: uuid(),\r\n\t\tname: 'Agent 4',\r\n\t\tavatar: '/assets/playerIcons/yellowUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: true\r\n\t},\r\n\t{\r\n\t\tid: uuid(),\r\n\t\tname: 'Agent 5',\r\n\t\tavatar: '/assets/playerIcons/brownUser.svg',\r\n\t\tcards: [],\r\n\t\tshowDownHand: {\r\n\t\t\thand: [],\r\n\t\t\tdescendingSortHand: [],\r\n\t\t},\r\n\t\tchips: 20000,\r\n\t\troundStartChips: 20000,\r\n\t\troundEndChips: 20000,\r\n\t\tcurrentRoundChipsInvested: 0,\r\n\t\tbet: 0,\r\n\t\tbetReconciled: false,\r\n\t\tfolded: false,\r\n\t\tallIn: false,\r\n\t\tcanRaise: true,\r\n\t\tstackInvestment: 0,\r\n\t\tagent: true\r\n\t}];\r\n\r\n\treturn users\r\n}\r\n/* \r\n Used to create agents of different difficulties\r\n */\r\nconst makePersonality = (seed) => {\r\n\tswitch (seed) {\r\n\t\t// intermediate/advanced ai\r\n\t\tcase (seed > 0.5):\r\n\t\t\treturn 'standard'\r\n\t\t// beginner ai\r\n\t\tcase (seed > 0.35):\r\n\t\t\treturn 'aggressive'\r\n\t\tcase (seed > 0):\r\n\t\t// intermediate/advanced ai\r\n\t\tdefault:\r\n\t\t\treturn 'conservative'\r\n\t}\r\n}\r\n\r\nconst manageOverflowIndex = (currentIndex, incrementBy, arrayLength, direction) => {\r\n\tswitch (direction) {\r\n\t\tcase ('up'): {\r\n\t\t\treturn (\r\n\t\t\t\t(currentIndex + incrementBy) % arrayLength\r\n\t\t\t)\r\n\t\t}\r\n\t\tcase ('down'): {\r\n\t\t\treturn (\r\n\t\t\t\t((currentIndex - incrementBy) % arrayLength) + arrayLength\r\n\t\t\t)\r\n\t\t}\r\n\t\tdefault: throw Error(\"Attempted to overfow index on unfamiliar direction\");\r\n\t}\r\n}\r\n/* \r\n Determines which player starts the round\r\n */\r\nconst choosePhaseStartActivePlayer = (state, recursion = false) => {\r\n\tif (!recursion) {\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.blindIndex.big, 1, state.players.length, 'up');\r\n\t} else if (recursion) {\r\n\t\tstate.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\r\n\t}\r\n\tif (state.players[state.activePlayerIndex].folded) {\r\n\t\treturn choosePhaseStartActivePlayer(state, true)\r\n\t}\r\n\tif (state.players[state.activePlayerIndex].chips === 0) {\r\n\t\treturn choosePhaseStartActivePlayer(state, true)\r\n\t}\r\n\treturn state\r\n}\r\n\r\n/* \r\n Determines which players turn is next\r\n */\r\nconst chooseNextActivePlayer = (state) => {\r\n\tstate.activePlayerIndex = manageOverflowIndex(state.activePlayerIndex, 1, state.players.length, 'up');\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\r\n\tconst allButOnePlayersAreAllIn = (state.playersActive - state.playersAllIn === 1);\r\n\tif (state.playersActive === 1) {\r\n\t\tconsole.log(\"Only one player active, skipping to showdown.\")\r\n\t\treturn (playerShowDown(remakePot(dealOtherCommunityCards(state))));\r\n\t}\r\n\tif (activePlayer.folded) {\r\n\t\tconsole.log(\"Current player index is folded, going to next active player.\")\r\n\t\treturn chooseNextActivePlayer(state);\r\n\t}\r\n\r\n\tif (\r\n\t\tallButOnePlayersAreAllIn &&\r\n\t\t!activePlayer.folded &&\r\n\t\tactivePlayer.betReconciled\r\n\t) {\r\n\t\treturn (playerShowDown(remakePot(dealOtherCommunityCards(state))));\r\n\t}\r\n\r\n\tif (activePlayer.chips === 0) {\r\n\t\tif (state.playersAllIn === state.playersActive) {\r\n\t\t\tconsole.log(\"All players are all in.\")\r\n\t\t\treturn (playerShowDown(remakePot(dealOtherCommunityCards(state))));\r\n\t\t} else if (allButOnePlayersAreAllIn && activePlayer.allIn) {\r\n\t\t\treturn (playerShowDown(remakePot(dealOtherCommunityCards(state))));\r\n\t\t} else {\r\n\t\t\treturn chooseNextActivePlayer(state);\r\n\t\t}\r\n\t}\r\n\r\n\tif (activePlayer.betReconciled) {\r\n\t\tconsole.log(\"Player is reconciled with pot, round betting cycle complete, proceed to next round.\")\r\n\t\treturn managePhaseShift(state);\r\n\t}\r\n\r\n\treturn state\r\n}\r\n\r\n/* \r\n The dealer chip is assigned to the \r\n player acting as the dealer in \r\n a given round.\r\n */\r\nconst moveDealerChip = (state) => {\r\n\tstate.dealerIndex = manageOverflowIndex(state.dealerIndex, 1, state.players.length, 'up');\r\n\tconst nextDealer = state.players[state.dealerIndex]\r\n\tif (nextDealer.chips === 0) {\r\n\t\treturn moveDealerChip(state)\r\n\t}\r\n\r\n\treturn findBrokePlayers(state, nextDealer.name);\r\n}\r\n\r\n\r\n/* \r\n Finds and remove players with no funds remaining,\r\n shifts dealer if necessary and prepares state for \r\n next game phase.\r\n */\r\nconst findBrokePlayers = (state, dealerID) => {\r\n\tstate.players = state.players.filter(player => player.chips > 0);\r\n\tconst newDealerIndex = state.players.findIndex(player => player.name === dealerID)\r\n\tstate.dealerIndex = newDealerIndex\r\n\tstate.activePlayerIndex = newDealerIndex\r\n\tif (state.players.length === 1) {\r\n\t\t// winner determined\r\n\t\treturn state\r\n\t} else if (state.players.length === 2) {\r\n\t\tstate.blindIndex.small = newDealerIndex;\r\n\t\tstate.blindIndex.big = manageOverflowIndex(newDealerIndex, 1, state.players.length, 'up');\r\n\t\tstate.players = anteUpBlinds(state.players, { bigBlindIndex: state.blindIndex.big, smallBlindIndex: state.blindIndex.small }, state.minBet).map(player => ({\r\n\t\t\t...player,\r\n\t\t\tcards: [],\r\n\t\t\tshowDownHand: {\r\n\t\t\t\thand: [],\r\n\t\t\t\tdescendingSortHand: [],\r\n\t\t\t},\r\n\t\t\troundStartChips: player.chips + player.bet,\r\n\t\t\tcurrentRoundChipsInvested: 0,\r\n\t\t\tbetReconciled: false,\r\n\t\t\tfolded: false,\r\n\t\t\tallIn: false,\r\n\t\t}))\r\n\t\tstate.playersAllIn = 0;\r\n\t\tstate.playersFolded = 0;\r\n\t\tstate.playersActive = state.players.length;\r\n\t} else {\r\n\t\tconst blindIndicies = calculateBlindIndices(newDealerIndex, state.players.length);\r\n\t\tstate.blindIndex = {\r\n\t\t\tbig: blindIndicies.bigBlindIndex,\r\n\t\t\tsmall: blindIndicies.smallBlindIndex,\r\n\t\t}\r\n\t\tstate.players = anteUpBlinds(state.players, blindIndicies, state.minBet).map(player => ({\r\n\t\t\t...player,\r\n\t\t\tcards: [],\r\n\t\t\tshowDownHand: {\r\n\t\t\t\thand: [],\r\n\t\t\t\tdescendingSortHand: [],\r\n\t\t\t},\r\n\t\t\troundStartChips: player.chips + player.bet,\r\n\t\t\tcurrentRoundChipsInvested: 0,\r\n\t\t\tbetReconciled: false,\r\n\t\t\tfolded: false,\r\n\t\t\tallIn: false,\r\n\t\t}))\r\n\t\tstate.playersAllIn = 0;\r\n\t\tstate.playersFolded = 0;\r\n\t\tstate.playersActive = state.players.length;\r\n\t}\r\n\treturn dealPlayerCards(state)\r\n}\r\n\r\n/* \r\n Increments state to next game phase and \r\n shifts dealer.\r\n */\r\nconst startNextRound = (state) => {\r\n\tstate.communityCards = [];\r\n\tstate.sidePots = [];\r\n\tstate.playerHierarchy = [];\r\n\tstate.showDownMessages = [];\r\n\tstate.deck = shuffleCards(makeDeckOfCards())\r\n\tstate.highBet = 20;\r\n\tstate.betInputValue = 20;\r\n\tstate.minBet = 20; // can export out to initialState\r\n\t// Unmount all cards so react can re-trigger animations\r\n\tconst { players } = state;\r\n\tconst clearPlayerCards = players.map(player => ({ ...player, cards: player.cards.map(card => { }) }))\r\n\tstate.players = clearPlayerCards;\r\n\treturn moveDealerChip(state)\r\n}\r\n\r\n/* \r\n Check if the game has a winner.\r\n */\r\nconst checkWin = players => {\r\n\treturn (players.filter(player => player.chips > 0).length === 1)\r\n}\r\n\r\nexport { makeTable, manageOverflowIndex, chooseNextActivePlayer, choosePhaseStartActivePlayer, startNextRound, checkWin };\r\n\r\n"]},"metadata":{},"sourceType":"module"}