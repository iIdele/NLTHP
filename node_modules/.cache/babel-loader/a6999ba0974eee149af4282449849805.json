{"ast":null,"code":"import { dealFlopCards, dealRiverCards, dealTurnCards, playerShowDown } from './cardsService.js';\nimport { chooseNextActivePlayer } from './playersService.js';\n/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/\n\n/* \r\n Determine which players are included in the current pot.\r\n*/\n\nconst calculatePots = (state, playerStacks) => {\n  // remove players who did not bet from pot\n  const commitedPlayers = playerStacks.filter(player => player.sidePotStack > 0);\n\n  if (commitedPlayers.length === 0) {\n    return state;\n  } else if (commitedPlayers.length === 1) {\n    // refund players who bet in excess of pot\n    const playerToRefund = state.players[state.players.findIndex(player => player.name === commitedPlayers[0].name)];\n    playerToRefund.chips = playerToRefund.chips + commitedPlayers[0].sidePotStack;\n    state.pot -= commitedPlayers[0].sidePotStack;\n    return state;\n  } // sort players\n\n\n  const ascBetPlayers = commitedPlayers.sort((a, b) => a.sidePotStack - b.sidePotStack);\n  const smallStackValue = ascBetPlayers[0].sidePotStack;\n  const builtSidePot = ascBetPlayers.reduce((acc, cur) => {\n    if (!cur.folded) {\n      acc.contestants.push(cur.name);\n    }\n\n    acc.potValue = acc.potValue + smallStackValue;\n    cur.sidePotStack = cur.sidePotStack - smallStackValue;\n    return acc;\n  }, {\n    contestants: [],\n    potValue: 0\n  });\n  state.sidePots.push(builtSidePot);\n  return calculatePots(state, ascBetPlayers);\n};\n/* \r\nDetermines the integrity of all bets.\r\n*/\n\n\nconst manageBet = (state, bet, min, max) => {\n  if (bet < min) {\n    state.betInputValue = min;\n    return console.log(\"Invalid Bet\");\n  }\n\n  if (bet > max) {\n    state.betInputValue = max;\n    return console.log(\"Invalid Bet\");\n  }\n\n  if (bet > state.highBet) {\n    // minbet and highbet may be condensed to a single property\n    state.highBet = bet;\n    state.minBet = state.highBet;\n\n    for (let player of state.players) {\n      if (!player.folded || !player.chips === 0) {\n        player.betReconciled = false;\n      }\n    }\n  }\n\n  const activePlayer = state.players[state.activePlayerIndex];\n  const subtractableChips = bet - activePlayer.bet;\n  activePlayer.bet = bet;\n  activePlayer.chips = activePlayer.chips - subtractableChips;\n\n  if (activePlayer.chips === 0) {\n    activePlayer.allIn = true;\n    state.playersAllIn++;\n  }\n\n  activePlayer.betReconciled = true;\n  return chooseNextActivePlayer(state);\n};\n\nconst managePhaseShift = state => {\n  switch (state.phase) {\n    case 'first round':\n      {\n        state.phase = 'flop';\n        return dealFlopCards(remakePot(state));\n      }\n\n    case 'second round':\n      {\n        state.phase = 'turn';\n        return dealTurnCards(remakePot(state));\n      }\n\n    case 'third round':\n      {\n        state.phase = 'river';\n        return dealRiverCards(remakePot(state));\n      }\n\n    case 'fourth round':\n      {\n        state.phase = 'showdown';\n        return playerShowDown(remakePot(state));\n      }\n\n    default:\n      throw Error(\"managePhaseShift() called from non-betting phase\");\n  }\n};\n\nconst calculateMinBet = (highBet, playerChipsStack, playerBet) => {\n  const playerTotalChips = playerChipsStack + playerBet;\n\n  if (playerTotalChips < highBet) {\n    return playerTotalChips;\n  } else {\n    return highBet;\n  }\n};\n\nconst calculateBlindIndices = (dealerIndex, numPlayers) => {\n  return {\n    bigBlindIndex: (dealerIndex + 2) % numPlayers,\n    smallBlindIndex: (dealerIndex + 1) % numPlayers\n  };\n};\n\nconst managePlayerFold = state => {\n  const activePlayer = state.players[state.activePlayerIndex];\n  activePlayer.folded = true;\n  activePlayer.betReconciled = true;\n  state.playersFolded++;\n  state.playersActive--;\n  const nextState = chooseNextActivePlayer(state);\n  return nextState;\n};\n/* \r\n Condenses mutiple pots into a single pot. \r\n*/\n\n\nconst condensePots = state => {\n  if (state.sidePots.length > 1) {\n    for (let i = 0; i < state.sidePots.length; i++) {\n      for (let n = i + 1; n < state.sidePots.length; n++) {\n        if (arrayIdentical(state.sidePots[i].contestants, state.sidePots[n].contestants)) {\n          state.sidePots[i].potValue = state.sidePots[i].potValue + state.sidePots[n].potValue;\n          state.sidePots = state.sidePots.filter((el, index) => index !== n);\n        }\n      }\n    }\n  }\n\n  return state;\n};\n\nconst anteUpBlinds = (players, blindIndices, minBet) => {\n  const {\n    bigBlindIndex,\n    smallBlindIndex\n  } = blindIndices;\n  players[bigBlindIndex].bet = minBet;\n  players[bigBlindIndex].chips = players[bigBlindIndex].chips - minBet;\n  players[smallBlindIndex].bet = minBet / 2;\n  players[smallBlindIndex].chips = players[smallBlindIndex].chips - minBet / 2;\n  return players;\n};\n\nconst arrayIdentical = (arr1, arr2) => {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return arr1.map(el => arr2.includes(el)).filter(bool => bool !== true).length !== 0 ? false : true;\n};\n/* \r\nCombine sidepots into a single pot to save resources.\r\n*/\n\n\nconst remakePot = state => {\n  for (let player of state.players) {\n    state.pot = state.pot + player.bet;\n    player.sidePotStack = player.bet;\n    player.betReconciled = false;\n  } // condense pots as processing each one requires expensive card comparator functions\n\n\n  state = condensePots(calculatePots(state, state.players));\n\n  for (let player of state.players) {\n    player.currentRoundChipsInvested += player.bet;\n    player.bet = 0; // reset all player bets to 0 for the start of the next round\n  }\n\n  state.minBet = 0; // reset markers which control min/max bet validation\n\n  state.highBet = 0;\n  state.betInputValue = 0;\n  return state;\n};\n\nexport { calculateBlindIndices, anteUpBlinds, calculateMinBet, manageBet, managePlayerFold, managePhaseShift, remakePot };","map":{"version":3,"sources":["C:/Users/manny/2021-ca400-idelegi2-puzzuos2/src/ui/src/services/betService.js"],"names":["dealFlopCards","dealRiverCards","dealTurnCards","playerShowDown","chooseNextActivePlayer","calculatePots","state","playerStacks","commitedPlayers","filter","player","sidePotStack","length","playerToRefund","players","findIndex","name","chips","pot","ascBetPlayers","sort","a","b","smallStackValue","builtSidePot","reduce","acc","cur","folded","contestants","push","potValue","sidePots","manageBet","bet","min","max","betInputValue","console","log","highBet","minBet","betReconciled","activePlayer","activePlayerIndex","subtractableChips","allIn","playersAllIn","managePhaseShift","phase","remakePot","Error","calculateMinBet","playerChipsStack","playerBet","playerTotalChips","calculateBlindIndices","dealerIndex","numPlayers","bigBlindIndex","smallBlindIndex","managePlayerFold","playersFolded","playersActive","nextState","condensePots","i","n","arrayIdentical","el","index","anteUpBlinds","blindIndices","arr1","arr2","map","includes","bool","currentRoundChipsInvested"],"mappings":"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","sourcesContent":["import { dealFlopCards, dealRiverCards, dealTurnCards, playerShowDown } from './cardsService.js';\r\nimport { chooseNextActivePlayer } from './playersService.js';\r\n\r\n/**\r\n* The betService provides all services players\r\n* need to make bets. It also handles calculations\r\n* relating to bets and the betting pot.\r\n*/\r\n\r\n/* \r\n Determine which players are included in the current pot.\r\n*/\r\nconst calculatePots = (state, playerStacks) => {\r\n\t// remove players who did not bet from pot\r\n\tconst commitedPlayers = playerStacks.filter(player => player.sidePotStack > 0)\r\n\tif (commitedPlayers.length === 0) {\r\n\t\treturn state\r\n\t}\r\n\telse if (commitedPlayers.length === 1) {\r\n\t\t// refund players who bet in excess of pot\r\n\t\tconst playerToRefund = state.players[state.players.findIndex(player => player.name === commitedPlayers[0].name)];\r\n\t\tplayerToRefund.chips = playerToRefund.chips + commitedPlayers[0].sidePotStack;\r\n\t\tstate.pot -= commitedPlayers[0].sidePotStack\r\n\t\treturn state\r\n\t}\r\n\t// sort players\r\n\tconst ascBetPlayers = commitedPlayers.sort((a, b) => a.sidePotStack - b.sidePotStack);\r\n\tconst smallStackValue = ascBetPlayers[0].sidePotStack;\r\n\r\n\tconst builtSidePot = ascBetPlayers.reduce((acc, cur) => {\r\n\t\tif (!cur.folded) {\r\n\t\t\tacc.contestants.push(cur.name);\r\n\t\t}\r\n\t\tacc.potValue = acc.potValue + smallStackValue;\r\n\t\tcur.sidePotStack = cur.sidePotStack - smallStackValue;\r\n\t\treturn acc\r\n\t}, {\r\n\t\tcontestants: [],\r\n\t\tpotValue: 0,\r\n\t});\r\n\tstate.sidePots.push(builtSidePot);\r\n\treturn calculatePots(state, ascBetPlayers)\r\n}\r\n\r\n/* \r\nDetermines the integrity of all bets.\r\n*/\r\nconst manageBet = (state, bet, min, max) => {\r\n\tif (bet < min) {\r\n\t\tstate.betInputValue = min;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\tif (bet > max) {\r\n\t\tstate.betInputValue = max;\r\n\t\treturn console.log(\"Invalid Bet\")\r\n\t}\r\n\r\n\tif (bet > state.highBet) {\r\n\t\t// minbet and highbet may be condensed to a single property\r\n\t\tstate.highBet = bet;\r\n\t\tstate.minBet = state.highBet;\r\n\t\tfor (let player of state.players) {\r\n\t\t\tif (!player.folded || !player.chips === 0) {\r\n\t\t\t\tplayer.betReconciled = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tconst subtractableChips = bet - activePlayer.bet;\r\n\tactivePlayer.bet = bet;\r\n\r\n\tactivePlayer.chips = activePlayer.chips - subtractableChips;\r\n\tif (activePlayer.chips === 0) {\r\n\t\tactivePlayer.allIn = true;\r\n\t\tstate.playersAllIn++\r\n\t}\r\n\tactivePlayer.betReconciled = true;\r\n\treturn chooseNextActivePlayer(state)\r\n}\r\n\r\nconst managePhaseShift = (state) => {\r\n\tswitch (state.phase) {\r\n\t\tcase ('first round'): {\r\n\t\t\tstate.phase = 'flop';\r\n\t\t\treturn dealFlopCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('second round'): {\r\n\t\t\tstate.phase = 'turn';\r\n\t\t\treturn dealTurnCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('third round'): {\r\n\t\t\tstate.phase = 'river'\r\n\t\t\treturn dealRiverCards(remakePot(state));\r\n\t\t}\r\n\t\tcase ('fourth round'): {\r\n\t\t\tstate.phase = 'showdown'\r\n\t\t\treturn playerShowDown(remakePot(state));\r\n\t\t}\r\n\t\tdefault: throw Error(\"managePhaseShift() called from non-betting phase\")\r\n\t}\r\n}\r\n\r\nconst calculateMinBet = (highBet, playerChipsStack, playerBet) => {\r\n\tconst playerTotalChips = playerChipsStack + playerBet\r\n\tif (playerTotalChips < highBet) {\r\n\t\treturn playerTotalChips;\r\n\t} else {\r\n\t\treturn highBet;\r\n\t}\r\n}\r\n\r\nconst calculateBlindIndices = (dealerIndex, numPlayers) => {\r\n\treturn ({\r\n\t\tbigBlindIndex: (dealerIndex + 2) % numPlayers,\r\n\t\tsmallBlindIndex: (dealerIndex + 1) % numPlayers,\r\n\t});\r\n}\r\n\r\nconst managePlayerFold = (state) => {\r\n\tconst activePlayer = state.players[state.activePlayerIndex];\r\n\tactivePlayer.folded = true;\r\n\tactivePlayer.betReconciled = true;\r\n\tstate.playersFolded++\r\n\tstate.playersActive--\r\n\r\n\tconst nextState = chooseNextActivePlayer(state)\r\n\treturn nextState\r\n}\r\n/* \r\n Condenses mutiple pots into a single pot. \r\n*/\r\nconst condensePots = (state) => {\r\n\tif (state.sidePots.length > 1) {\r\n\t\tfor (let i = 0; i < state.sidePots.length; i++) {\r\n\t\t\tfor (let n = i + 1; n < state.sidePots.length; n++) {\r\n\t\t\t\tif (arrayIdentical(state.sidePots[i].contestants, state.sidePots[n].contestants)) {\r\n\t\t\t\t\tstate.sidePots[i].potValue = state.sidePots[i].potValue + state.sidePots[n].potValue;\r\n\t\t\t\t\tstate.sidePots = state.sidePots.filter((el, index) => index !== n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn state\r\n}\r\n\r\nconst anteUpBlinds = (players, blindIndices, minBet) => {\r\n\tconst { bigBlindIndex, smallBlindIndex } = blindIndices;\r\n\tplayers[bigBlindIndex].bet = minBet;\r\n\tplayers[bigBlindIndex].chips = players[bigBlindIndex].chips - minBet;\r\n\tplayers[smallBlindIndex].bet = minBet / 2;\r\n\tplayers[smallBlindIndex].chips = players[smallBlindIndex].chips - (minBet / 2);\r\n\treturn players\r\n}\r\n\r\nconst arrayIdentical = (arr1, arr2) => {\r\n\r\n\tif (arr1.length !== arr2.length) {\r\n\t\treturn false\r\n\t}\r\n\treturn arr1.map(el => arr2.includes(el)).filter(bool => bool !== true).length !== 0 ? false : true;\r\n}\r\n\r\n/* \r\nCombine sidepots into a single pot to save resources.\r\n*/\r\nconst remakePot = (state) => {\r\n\tfor (let player of state.players) {\r\n\r\n\t\tstate.pot = state.pot + player.bet;\r\n\r\n\t\tplayer.sidePotStack = player.bet;\r\n\t\tplayer.betReconciled = false;\r\n\t}\r\n\r\n\t// condense pots as processing each one requires expensive card comparator functions\r\n\tstate = condensePots(calculatePots(state, state.players));\r\n\r\n\tfor (let player of state.players) {\r\n\t\tplayer.currentRoundChipsInvested += player.bet;\r\n\t\tplayer.bet = 0 // reset all player bets to 0 for the start of the next round\r\n\t}\r\n\r\n\tstate.minBet = 0; // reset markers which control min/max bet validation\r\n\tstate.highBet = 0;\r\n\tstate.betInputValue = 0;\r\n\treturn state\r\n}\r\n\r\nexport {\r\n\tcalculateBlindIndices,\r\n\tanteUpBlinds,\r\n\tcalculateMinBet,\r\n\tmanageBet,\r\n\tmanagePlayerFold,\r\n\tmanagePhaseShift,\r\n\tremakePot\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}